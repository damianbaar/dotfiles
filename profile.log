SCRIPT  /usr/local/Cellar/neovim/HEAD/share/nvim/runtime/scripts.vim
Sourced 1 time
Total time:   0.003469
 Self time:   0.003469

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2014 Aug 24
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    1              0.000012 if did_filetype()
                              finish
                            endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    1              0.000021 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
                            endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000033 let s:cpo_save = &cpo
    1              0.000026 set cpo&vim
                            
    1              0.000017 let s:line1 = getline(1)
                            
    1              0.000021 if s:line1 =~ "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~ '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~ '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~ '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~ '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~ '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~ '^csh\>'
                                if exists("g:filetype_csh")
                                  call SetFileTypeShell(g:filetype_csh)
                                else
                                  call SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~ '^tcsh\>'
                                call SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~ '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~ '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~ '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~ '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~ 'make\>'
                                set ft=make
                            
                                " Lua
                              elseif s:name =~ 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~ 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~ 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~ 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~ 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~ '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~ 'ruby'
                                set ft=ruby
                            
                                " BC calculator
                              elseif s:name =~ '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~ 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~ 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~ 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~ 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~ 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~ 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~ 'escript'
                                set ft=erlang
                            
                              endif
                              unlet s:name
                            
                            else
                              " File does not start with "#!".
                            
    1              0.000018   let s:line2 = getline(2)
    1              0.000012   let s:line3 = getline(3)
    1              0.000011   let s:line4 = getline(4)
    1              0.000012   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    1              0.000043   if s:line1 =~ '^:$'
                                call SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " Z shell scripts
                              elseif s:line1 =~ '^#compdef\>' || s:line1 =~ '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~ '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
                              elseif s:line1 =~ '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                                " Mason
                              elseif s:line1 =~ '^<[%&].*>'
                                set ft=mason
                            
                                " Vim scripts (must have '" vim' as the first line to trigger this)
                              elseif s:line1 =~ '^" *[vV]im$'
                                set ft=vim
                            
                                " MOO
                              elseif s:line1 =~ '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
                              elseif s:line1 =~ '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~ '^--- ' && s:line2 =~ '^+++ ')
                            	\ || (s:line1 =~ '^\* looking for ' && s:line2 =~ '^\* comparing to ')
                            	\ || (s:line1 =~ '^\*\*\* ' && s:line2 =~ '^--- ')
                            	\ || (s:line1 =~ '^=== ' && ((s:line2 =~ '^=\{66\}' && s:line3 =~ '^--- ' && s:line4 =~ '^+++') || (s:line2 =~ '^--- ' && s:line3 =~ '^+++ ')))
                            	\ || (s:line1 =~ '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
                              elseif s:line1 =~ '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
                              elseif s:line1 =~ '^\s*dnl\>'
                            	\ || s:line2 =~ '^\s*dnl\>'
                            	\ || s:line3 =~ '^\s*dnl\>'
                            	\ || s:line4 =~ '^\s*dnl\>'
                            	\ || s:line5 =~ '^\s*dnl\>'
                                set ft=m4
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
                              elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
                              elseif s:line1 =~ '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
                              elseif s:line1 =~ '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                              elseif s:line1 =~ '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                              elseif s:line1 =~? '\<DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
                              elseif s:line1 =~ '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
                              elseif s:line1 =~ '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
                              elseif s:line1 =~ '^RCS file:' || s:line2 =~ '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
                              elseif s:line2 =~ '^CVS:' || getline("$") =~ '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
                              elseif s:line1 =~ '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
                              elseif s:line1 =~ '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
                              elseif s:line1 =~ '^SNNS network definition file'
                                set ft=snnsnet
                              elseif s:line1 =~ '^SNNS pattern definition file'
                                set ft=snnspat
                              elseif s:line1 =~ '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
                              elseif s:line1 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~ '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~ '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
                              elseif s:line1 =~ '^\(\[pid \d\+\] \)\=[0-9:.]* *execve(' || s:line1 =~ '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
                              elseif s:line1 =~ '^\* $$ JOB\>' || s:line1 =~ '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
                              elseif s:line4 =~ 'K & K  Associates' || s:line2 =~ 'TAK 2000'
                                set ft=takout
                              elseif s:line3 =~ 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
                              elseif getline(6) =~ 'Run Date: '
                                set ft=takcmp
                              elseif getline(9) =~ 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
                              elseif s:line1.s:line2.s:line3.s:line4 =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
                              elseif s:line1 =~ '|\*\{1,80}' && s:line2 =~ 'VRC '
                            	\ || s:line2 =~ '|\*\{1,80}' && s:line3 =~ 'VRC '
                                set ft=baan
                            
                              " Valgrind
                              elseif s:line1 =~ '^==\d\+== valgrind' || s:line3 =~ '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
                              elseif s:line1 =~ '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
                              elseif s:line1 =~ '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
                              elseif s:line1 =~ 'exec\s\+\S*scheme' || s:line2 =~ 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
                              elseif s:line1 =~ '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
                               elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~ '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
                              elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " CVS diff
                              else
    1              0.000011     let s:lnum = 1
    1              0.000021     while getline(s:lnum) =~ "^? " && s:lnum < line("$")
                                  let s:lnum += 1
                                endwhile
    1              0.000015     if getline(s:lnum) =~ '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                elseif expand("%") =~ '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~ '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
                                endif
    1              0.000006     unlet s:lnum
                            
    1              0.000003   endif
                            
    1              0.000007   unlet s:line2 s:line3 s:line4 s:line5
                            
    1              0.000003 endif
                            
                            " Restore 'cpoptions'
    1              0.000026 let &cpo = s:cpo_save
                            
    1              0.000014 unlet s:cpo_save s:line1

SCRIPT  /Users/damianbaar/.vim/bundle/ctrlp.vim/autoload/ctrlp/utils.vim
Sourced 1 time
Total time:   0.000591
 Self time:   0.000347

count  total (s)   self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp/utils.vim
                            " Description:   Utilities
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            
                            " Static variables {{{1
    1              0.000013 fu! ctrlp#utils#lash()
                            	retu &ssl || !exists('+ssl') ? '/' : '\'
                            endf
                            
    1              0.000008 fu! s:lash(...)
                            	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
                            endf
                            
    1              0.000007 fu! ctrlp#utils#opts()
                            	let s:lash = ctrlp#utils#lash()
                            	let usrhome = $HOME . s:lash( $HOME )
                            	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
                            	let cadir = isdirectory(usrhome.'.ctrlp_cache')
                            		\ ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
                            	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
                            	let s:cache_dir = cadir
                            endf
    1   0.000272   0.000027 cal ctrlp#utils#opts()
                            
    1              0.000012 let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
                            " Files and Directories {{{1
    1              0.000009 fu! ctrlp#utils#cachedir()
                            	retu s:cache_dir
                            endf
                            
    1              0.000008 fu! ctrlp#utils#cachefile(...)
                            	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
                            	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
                            	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file
                            endf
                            
    1              0.000007 fu! ctrlp#utils#readfile(file)
                            	if filereadable(a:file)
                            		let data = readfile(a:file)
                            		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
                            		retu data
                            	en
                            	retu []
                            endf
                            
    1              0.000007 fu! ctrlp#utils#mkdir(dir)
                            	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
                            	retu a:dir
                            endf
                            
    1              0.000008 fu! ctrlp#utils#writecache(lines, ...)
                            	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
                            		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
                            	en
                            endf
                            
    1              0.000008 fu! ctrlp#utils#glob(...)
                            	let path = ctrlp#utils#fnesc(a:1, 'g')
                            	retu s:wig_cond ? glob(path, a:2) : glob(path)
                            endf
                            
    1              0.000007 fu! ctrlp#utils#globpath(...)
                            	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])
                            endf
                            
    1              0.000008 fu! ctrlp#utils#fnesc(path, type, ...)
                            	if exists('*fnameescape')
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = fnameescape(a:path)
                            		en
                            	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
                            	en
                            	retu a:0 ? escape(path, a:1) : path
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

SCRIPT  /Users/damianbaar/.vim/bundle/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim
Sourced 1 time
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2015 Bailey Ling.
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000027 let s:fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
    1              0.000020 let s:fnamecollapse = get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
    1              0.000019 let s:fnametruncate = get(g:, 'airline#extensions#tabline#fnametruncate', 0)
    1              0.000015 let s:buf_nr_format = get(g:, 'airline#extensions#tabline#buffer_nr_format', '%s: ')
    1              0.000010 let s:buf_nr_show = get(g:, 'airline#extensions#tabline#buffer_nr_show', 0)
    1              0.000011 let s:buf_modified_symbol = g:airline_symbols.modified
                            
    1              0.000021 function! airline#extensions#tabline#formatters#default#format(bufnr, buffers)
                              let _ = ''
                            
                              let name = bufname(a:bufnr)
                              if empty(name)
                                let _ .= '[No Name]'
                              else
                                if s:fnamecollapse
                                  let _ .= substitute(fnamemodify(name, s:fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
                                else
                                  let _ .= fnamemodify(name, s:fmod)
                                endif
                                if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
                              endif
                            
                              return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)
                            endfunction
                            
    1              0.000015 function! airline#extensions#tabline#formatters#default#wrap_name(bufnr, buffer_name)
                              let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
                              let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
                              if getbufvar(a:bufnr, '&modified') == 1
                                let _ .= s:buf_modified_symbol
                              endif
                              return _
                            endfunction

SCRIPT  /Users/damianbaar/.vim/bundle/vim-misc/autoload/xolox/misc/option.vim
Sourced 1 time
Total time:   0.000324
 Self time:   0.000324

count  total (s)   self (s)
                            " Vim and plug-in option handling.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: April 1, 2015
                            " URL: http://peterodding.com/code/vim/misc/
                            
    1              0.000021 function! xolox#misc#option#get(name, ...) " {{{1
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
                              if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
                                return a:1
                              endif
                            endfunction
                            
    1              0.000009 function! xolox#misc#option#split(value) " {{{1
                              " Given a multi-value Vim option like ['runtimepath'] [rtp] this returns a
                              " list of strings. For example:
                              "
                              "     :echo xolox#misc#option#split(&runtimepath)
                              "     ['/home/peter/Projects/Vim/misc',
                              "      '/home/peter/Projects/Vim/colorscheme-switcher',
                              "      '/home/peter/Projects/Vim/easytags',
                              "      ...]
                              "
                              " [rtp]: http://vimdoc.sourceforge.net/htmldoc/options.html#'runtimepath'
                              let values = split(a:value, '[^\\]\zs,')
                              return map(values, 's:unescape(v:val)')
                            endfunction
                            
    1              0.000012 function! s:unescape(s)
                              return substitute(a:s, '\\\([\\,]\)', '\1', 'g')
                            endfunction
                            
    1              0.000009 function! xolox#misc#option#join(values) " {{{1
                              " Given a list of strings like the ones returned by
                              " `xolox#misc#option#split()`, this joins the strings together into a
                              " single value that can be used to set a Vim option.
                              let values = copy(a:values)
                              call map(values, 's:escape(v:val)')
                              return join(values, ',')
                            endfunction
                            
    1              0.000006 function! s:escape(s)
                              return escape(a:s, ',\')
                            endfunction
                            
    1              0.000009 function! xolox#misc#option#split_tags(value) " {{{1
                              " Customized version of `xolox#misc#option#split()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              "
                              " [tags]: http://vimdoc.sourceforge.net/htmldoc/options.html#'tags'
                              let values = split(a:value, '[^\\]\zs,')
                              return map(values, 's:unescape_tags(v:val)')
                            endfunction
                            
    1              0.000006 function! s:unescape_tags(s)
                              return substitute(a:s, '\\\([\\, ]\)', '\1', 'g')
                            endfunction
                            
    1              0.000008 function! xolox#misc#option#join_tags(values) " {{{1
                              " Customized version of `xolox#misc#option#join()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              let values = copy(a:values)
                              call map(values, 's:escape_tags(v:val)')
                              return join(values, ',')
                            endfunction
                            
    1              0.000005 function! s:escape_tags(s)
                              return escape(a:s, ', ')
                            endfunction
                            
    1              0.000008 function! xolox#misc#option#eval_tags(value, ...) " {{{1
                              " Evaluate Vim's ['tags' option] [tags] without looking at the file
                              " system, i.e. this will report tags files that don't exist yet. Expects
                              " the value of the ['tags' option] [tags] as the first argument. If the
                              " optional second argument is 1 (true) only the first match is returned,
                              " otherwise (so by default) a list with all matches is returned.
                              let pathnames = []
                              let first_only = exists('a:1') ? a:1 : 0
                              for pattern in xolox#misc#option#split_tags(a:value)
                                " Make buffer relative pathnames absolute.
                                if pattern =~ '^\./'
                                  let suffix = matchstr(pattern, '^./\zs.*$')
                                  let directory = (&cpoptions =~# 'd') ? getcwd() : expand('%:p:h')
                                  let pattern = xolox#misc#path#merge(directory, suffix)
                                endif
                                " Make working directory relative pathnames absolute.
                                if xolox#misc#path#is_relative(pattern)
                                  let pattern = xolox#misc#path#merge(getcwd(), pattern)
                                endif
                                " Ignore the trailing `;' for recursive upwards searching because we
                                " always want the most specific pathname available.
                                let pattern = substitute(pattern, ';$', '', '')
                                " Expand the pattern.
                                call extend(pathnames, split(expand(pattern), "\n"))
                                if first_only && !empty(pathnames)
                                  return pathnames[0]
                                endif
                              endfor
                              return first_only ? '' : pathnames
                            endfunction
                            
                            " vim: ts=2 sw=2 et

SCRIPT  /Users/damianbaar/.vim/bundle/vim-misc/autoload/xolox/misc/path.vim
Sourced 1 time
Total time:   0.000758
 Self time:   0.000727

count  total (s)   self (s)
                            " Pathname manipulation functions.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: July 7, 2014
                            " URL: http://peterodding.com/code/vim/misc/
                            
    1   0.000066   0.000035 let s:windows_compatible = xolox#misc#os#is_win()
                            
    1              0.000011 function! xolox#misc#path#which(...) " {{{1
                              " Scan the executable search path (`$PATH`) for one or more external
                              " programs. Expects one or more string arguments with program names. Returns
                              " a list with the absolute pathnames of all found programs. Here's an
                              " example:
                              "
                              "     :echo xolox#misc#path#which('gvim', 'vim')
                              "     ['/usr/local/bin/gvim',
                              "      '/usr/bin/gvim',
                              "      '/usr/local/bin/vim',
                              "      '/usr/bin/vim']
                              let extensions = s:windows_compatible ? split($PATHEXT, ';') : ['']
                              let matches = []
                              let checked = {}
                              for program in a:000
                                for directory in split($PATH, s:windows_compatible ? ';' : ':')
                                  let directory = xolox#misc#path#absolute(directory)
                                  if isdirectory(directory)
                                    let found = 0
                                    for extension in extensions
                                      let path = xolox#misc#path#merge(directory, program . extension)
                                      if executable(path)
                                        call add(matches, path)
                                        let found = 1
                                      endif
                                    endfor
                                    if s:windows_compatible && ! found
                                      " Maybe the extension is already contained in program; try without
                                      " $PATHEXT.
                                      let path = xolox#misc#path#merge(directory, program)
                                      if executable(path)
                                        call add(matches, path)
                                      endif
                                    endif
                                  endif
                                endfor
                              endfor
                              return xolox#misc#list#unique(matches)
                            endfunction
                            
    1              0.000008 function! xolox#misc#path#split(path) " {{{1
                              " Split a pathname (the first and only argument) into a list of pathname
                              " components.
                              "
                              " On Windows, pathnames starting with two slashes or backslashes are UNC
                              " paths where the leading slashes are significant... In this case we split
                              " like this:
                              "
                              " - Input: `'//server/share/directory'`
                              " - Result: `['//server', 'share', 'directory']`
                              "
                              " Everything except Windows is treated like UNIX until someone has a better
                              " suggestion :-). In this case we split like this:
                              "
                              " - Input: `'/foo/bar/baz'`
                              " - Result: `['/', 'foo', 'bar', 'baz']`
                              "
                              " To join a list of pathname components back into a single pathname string,
                              " use the `xolox#misc#path#join()` function.
                              if type(a:path) == type('')
                                if s:windows_compatible
                                  if a:path =~ '^[\/][\/]'
                                    " UNC pathname.
                                    return split(a:path, '\%>2c[\/]\+')
                                  else
                                    " If it's not a UNC pathname we can simply split on slashes and
                                    " backslashes, although we should preserve a leading slash (which
                                    " denotes a pathname that is 'absolute to the current drive').
                                    let absolute = (a:path =~ '^[\/]')
                                    let segments = split(a:path, '[\/]\+')
                                    return absolute ? insert(segments, a:path[0]) : segments
                                  endif
                                else
                                  " Everything else is treated as UNIX.
                                  let absolute = (a:path =~ '^/')
                                  let segments = split(a:path, '/\+')
                                  return absolute ? insert(segments, '/') : segments
                                endif
                              endif
                              return []
                            endfunction
                            
    1              0.000008 function! xolox#misc#path#join(parts) " {{{1
                              " Join a list of pathname components (the first and only argument) into a
                              " single pathname string. This is the counterpart to the
                              " `xolox#misc#path#split()` function and it expects a list of pathname
                              " components as returned by `xolox#misc#path#split()`.
                              if type(a:parts) == type([])
                                if s:windows_compatible
                                  return join(a:parts, xolox#misc#path#directory_separator())
                                elseif get(a:parts, 0) == '/'
                                  " Absolute path on UNIX (non-Windows).
                                  return '/' . join(a:parts[1:], '/')
                                else
                                  " Relative path on UNIX (non-Windows).
                                  return join(a:parts, '/')
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000009 function! xolox#misc#path#directory_separator() " {{{1
                              " Find the preferred directory separator for the platform and settings.
                              return exists('+shellslash') && &shellslash ? '/' : '\'
                            endfunction
                            
    1              0.000016 function! xolox#misc#path#absolute(path) " {{{1
                              " Canonicalize and resolve a pathname, *regardless of whether it exists*.
                              " This is intended to support string comparison to determine whether two
                              " pathnames point to the same directory or file.
                              if type(a:path) == type('')
                                let path = a:path
                                " Make the pathname absolute.
                                if path =~ '^\~'
                                  " Expand ~ to $HOME.
                                  let path = $HOME . '/' . path[1:]
                                elseif xolox#misc#path#is_relative(path)
                                  " Make relative pathnames absolute.
                                  let path = getcwd() . '/' . path
                                endif
                                " Resolve symbolic links to find the canonical pathname. In my tests this
                                " also removes all symbolic pathname segments (`.' and `..'), even when
                                " the pathname does not exist. Also there used to be a bug in resolve()
                                " where it wouldn't resolve pathnames ending in a directory separator.
                                " Since it's not much trouble to work around, that's what we do.
                                let path = resolve(substitute(path, s:windows_compatible ? '[\/]\+$' : '/\+$', '', ''))
                                " Normalize directory separators (especially relevant on Windows).
                                let parts = xolox#misc#path#split(path)
                                if s:windows_compatible && parts[0] =~ '^[\/][\/]'
                                  " Also normalize the two leading "directory separators" (I'm not
                                  " sure what else to call them :-) in Windows UNC pathnames.
                                  let parts[0] = repeat(xolox#misc#path#directory_separator(), 2) . parts[0][2:]
                                elseif s:windows_compatible && parts[0] =~ '^[\/]$'
                                  " If a pathname is relative to the current drive we should add
                                  " the drive letter in order to make the pathname absolute.
                                  let parts[0] = matchstr(getcwd(), '^\a:')
                                endif
                                return xolox#misc#path#join(parts)
                              endif
                              return ''
                            endfunction
                            
    1              0.000008 function! xolox#misc#path#relative(path, base) " {{{1
                              " Make an absolute pathname (the first argument) relative to a directory
                              " (the second argument).
                              let path = xolox#misc#path#split(a:path)
                              let base = xolox#misc#path#split(a:base)
                              while path != [] && base != [] && path[0] == base[0]
                                call remove(path, 0)
                                call remove(base, 0)
                              endwhile
                              let distance = repeat(['..'], len(base))
                              return xolox#misc#path#join(distance + path)
                            endfunction
                            
    1              0.000008 function! xolox#misc#path#merge(parent, child, ...) " {{{1
                              " Join a directory pathname and filename into a single pathname.
                              if type(a:parent) == type('') && type(a:child) == type('')
                                " TODO Use xolox#misc#path#is_relative()?
                                if s:windows_compatible
                                  let parent = substitute(a:parent, '[\\/]\+$', '', '')
                                  let child = substitute(a:child, '^[\\/]\+', '', '')
                                  return parent . '\' . child
                                else
                                  let parent = substitute(a:parent, '/\+$', '', '')
                                  let child = substitute(a:child, '^/\+', '', '')
                                  return parent . '/' . child
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000008 function! xolox#misc#path#commonprefix(paths) " {{{1
                              " Find the common prefix of path components in a list of pathnames.
                              let common = xolox#misc#path#split(a:paths[0])
                              for path in a:paths
                                let index = 0
                                for segment in xolox#misc#path#split(path)
                                  if len(common) <= index
                                    break
                                  elseif common[index] != segment
                                    call remove(common, index, -1)
                                    break
                                  endif
                                  let index += 1
                                endfor
                              endfor
                              return xolox#misc#path#join(common)
                            endfunction
                            
    1              0.000009 function! xolox#misc#path#starts_with(a, b) " {{{1
                              " Check whether the first pathname starts with the second pathname (expected
                              " to be a directory). This does not perform a regular string comparison;
                              " first it normalizes both pathnames, then it splits them into their
                              " pathname segments and then it compares the segments.
                              let a = xolox#misc#path#split(xolox#misc#path#absolute(a:a))
                              let b = xolox#misc#path#split(xolox#misc#path#absolute(a:b))
                              return a[0 : len(b) - 1] == b
                            endfunction
                            
    1              0.000008 function! xolox#misc#path#encode(path) " {{{1
                              " Encode a pathname so it can be used as a filename. This uses URL encoding
                              " to encode special characters.
                              if s:windows_compatible
                                let mask = '[*|\\/:"<>?%]'
                              elseif xolox#misc#os#is_mac()
                                let mask = '[\\/%:]'
                              else
                                let mask = '[\\/%]'
                              endif
                              return substitute(a:path, mask, '\=printf("%%%x", char2nr(submatch(0)))', 'g')
                            endfunction
                            
    1              0.000008 function! xolox#misc#path#decode(encoded_path) " {{{1
                              " Decode a pathname previously encoded with `xolox#misc#path#encode()`.
                              return substitute(a:encoded_path, '%\(\x\x\?\)', '\=nr2char("0x" . submatch(1))', 'g')
                            endfunction
                            
                            " xolox#misc#path#equals(a, b) - Check whether two pathnames point to the same file. {{{1
                            
    1              0.000007 if s:windows_compatible
                              function! xolox#misc#path#equals(a, b)
                                return a:a ==? a:b || xolox#misc#path#absolute(a:a) ==? xolox#misc#path#absolute(a:b)
                              endfunction
                            else
    1              0.000008   function! xolox#misc#path#equals(a, b)
                                return a:a ==# a:b || xolox#misc#path#absolute(a:a) ==# xolox#misc#path#absolute(a:b)
                              endfunction
    1              0.000003 endif
                            
    1              0.000008 function! xolox#misc#path#is_relative(path) " {{{1
                              " Returns true (1) when the pathname given as the first argument is
                              " relative, false (0) otherwise.
                              if a:path =~ '^\w\+://'
                                return 0
                              elseif s:windows_compatible
                                return a:path !~ '^\(\w:\|[\\/]\)'
                              else
                                return a:path !~ '^/'
                              endif
                            endfunction
                            
    1              0.000008 function! xolox#misc#path#tempdir() " {{{1
                              " Create a temporary directory and return the pathname of the directory.
                              if !exists('s:tempdir_counter')
                                let s:tempdir_counter = 1
                              endif
                              if exists('*mkdir')
                                if s:windows_compatible
                                  let template = $TMP . '\vim_tempdir_'
                                elseif filewritable('/tmp') == 2
                                  let template = '/tmp/vim_tempdir_'
                                endif
                              endif
                              if !exists('template')
                                throw "xolox#misc#path#tempdir() hasn't been implemented on your platform!"
                              endif
                              while 1
                                let directory = template . s:tempdir_counter
                                try
                                  call mkdir(directory, '', 0700)
                                  return directory
                                catch /^Vim\%((\a\+)\)\=:E739/
                                  " Keep looking for a non-existing directory.
                                endtry
                                let s:tempdir_counter += 1
                              endwhile
                            endfunction
                            
                            " vim: ts=2 sw=2 et

FUNCTION  4()
Called 2 times
Total time:   0.000294
 Self time:   0.000054

count  total (s)   self (s)
    2   0.000067   0.000026     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    2   0.000224   0.000025     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  5()
Called 2 times
Total time:   0.000199
 Self time:   0.000107

count  total (s)   self (s)
    2   0.000057   0.000021     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    2   0.000026   0.000014     if !a:loclist.isEmpty()
                                    if syntastic#util#var('auto_loc_list') == 1
                                        call a:loclist.show()
                                    endif
                                else
    2   0.000060   0.000016         if syntastic#util#var('auto_loc_list') > 0
                            
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
    2              0.000008             lclose
    2              0.000004         endif
    2              0.000004     endif

FUNCTION  7()
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000026     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  9()
Called 1 time
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000008     let b:syntastic_private_balloons = {}
    1              0.000010     if has('balloon_eval')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    unlet! b:syntastic_private_balloons
                                    set noballooneval
                                endif

FUNCTION  xolox#session#find_current_session()
Called 1 time
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
                              " Find the name of the current tab scoped or global session. Returns a
                              " string. If no session is active an empty string is returned.
    3              0.000018   for variable in ['t:this_session', 'v:this_session']
    2              0.000015     if exists(variable)
    1              0.000009       let filename = eval(variable)
    1              0.000005       if !empty(filename)
                                    let directory = fnamemodify(filename, ':p:h')
                                    if xolox#misc#path#equals(directory, g:session_directory)
                                      return xolox#session#path_to_name(filename)
                                    endif
                                  endif
    1              0.000002     endif
    2              0.000008   endfor
    1              0.000003   return ''

FUNCTION  <SNR>39__is_quitting()
Called 2 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    2              0.000010     let quitting = 0
    2              0.000016     if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
    2              0.000009     return quitting

FUNCTION  <SNR>122_get_prev_group()
Called 35 times
Total time:   0.001323
 Self time:   0.001323

count  total (s)   self (s)
   35              0.000202   let x = a:i - 1
   42              0.000156   while x >= 0
   38              0.000289     let group = a:sections[x][0]
   38              0.000225     if group != '' && group != '|'
   31              0.000118       return group
                                endif
    7              0.000028     let x = x - 1
    7              0.000022   endwhile
    4              0.000013   return ''

FUNCTION  <SNR>52_mergelists()
Called 2 times
Total time:   0.006750
 Self time:   0.004296

count  total (s)   self (s)
    2   0.002459   0.000067 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    2              0.003938 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    2              0.000234 	let mrufs = s:mrufs + diskmrufs
    2   0.000112   0.000050 	retu s:chop(mrufs)

FUNCTION  <SNR>87_Highlight_Matching_Pair()
Called 5 times
Total time:   0.033252
 Self time:   0.033252

count  total (s)   self (s)
                              " Remove any previous match.
    5              0.000125   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    5              0.000104   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    5              0.000071   let c_lnum = line('.')
    5              0.000110   let c_col = col('.')
    5              0.000032   let before = 0
                            
    5              0.000067   let text = getline(c_lnum)
    5              0.000078   let c = text[c_col - 1]
    5              0.000305   let plist = split(&matchpairs, '.\zs[:,]')
    5              0.000077   let i = index(plist, c)
    5              0.000031   if i < 0
                                " not found, in Insert mode try character before the cursor
    4              0.000052     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = 1
                                  let c = text[c_col - 2]
                                  let i = index(plist, c)
                                endif
    4              0.000021     if i < 0
                                  " not found, nothing to do
    4              0.000022       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
    1              0.000004   if i % 2 == 0
    1              0.000005     let s_flags = 'nW'
    1              0.000008     let c2 = plist[i + 1]
    1              0.000002   else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
    1              0.000005   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    1              0.000004   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    1              0.000014   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
    1              0.000106   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    1              0.000019   let stoplinebottom = line('w$')
    1              0.000006   let stoplinetop = line('w0')
    1              0.000004   if i % 2 == 0
    1              0.000006     let stopline = stoplinebottom
    1              0.000002   else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    1              0.000009   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
    1              0.000013     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    1              0.000002   endif
    1              0.000003   try
    1              0.031170     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    1              0.000011   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    1              0.000005   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
    1              0.000007   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>39_ClearCache()
Called 1 time
Total time:   0.001006
 Self time:   0.000051

count  total (s)   self (s)
    1   0.000810   0.000027     call s:notifiers.reset(g:SyntasticLoclist.current())
    1   0.000194   0.000021     call b:syntastic_loclist.destroy()

FUNCTION  <SNR>80_activateFileNode()
Called 1 time
Total time:   0.296358
 Self time:   0.000025

count  total (s)   self (s)
    1   0.296357   0.000024     call a:node.activate({'reuse': 'all', 'where': 'p'})

FUNCTION  <SNR>20_on_window_changed()
Called 3 times
Total time:   0.038885
 Self time:   0.000128

count  total (s)   self (s)
    3              0.000019   if pumvisible()
                                return
                              endif
    3   0.000069   0.000042   call s:init()
    3   0.038773   0.000044   call airline#update_statusline()

FUNCTION  airline#check_mode()
Called 13 times
Total time:   0.029898
 Self time:   0.004402

count  total (s)   self (s)
   13              0.000193   let context = s:contexts[a:winnr]
                            
   13              0.000141   if get(w:, 'airline_active', 1)
   13              0.000119     let l:m = mode()
   13              0.000080     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
   13              0.000086       let l:mode = ['normal']
   13              0.000071     endif
   13              0.000218     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   13              0.000035   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
   13              0.000190   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
   13              0.000072   if g:airline_detect_paste && &paste
    7              0.000195     call add(l:mode, 'paste')
    7              0.000018   endif
                            
   13              0.000240   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   13              0.000072   if &readonly || ! &modifiable
   11              0.000242     call add(l:mode, 'readonly')
   11              0.000030   endif
                            
   13              0.000220   let mode_string = join(l:mode)
   13              0.000197   if get(w:, 'airline_lastmode', '') != mode_string
    2   0.000742   0.000119     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    2   0.024939   0.000065     call airline#highlighter#highlight(l:mode)
    2              0.000016     let w:airline_lastmode = mode_string
    2              0.000004   endif
                            
   13              0.000047   return ''

FUNCTION  <SNR>102_IndentLinesDisable()
Called 1 time
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    1              0.000008     let b:indentLine_enabled = 0
    1              0.000003     try
    1              0.000011         syntax clear IndentLine
    1              0.000025         syntax clear IndentLineSpace
                                catch /^Vim\%((\a\+)\)\=:E28/	" catch error E28
    1              0.000005     endtry

FUNCTION  ctrlp#utils#cachedir()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	retu s:cache_dir

FUNCTION  airline#util#append()
Called 8 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
    8              0.000044   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
    8              0.000071   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
    8              0.000072   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>118_get_syn()
Called 204 times
Total time:   0.015797
 Self time:   0.015797

count  total (s)   self (s)
                              " need to pass in mode, known to break on 7.3.547
  204              0.002831   let mode = has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? 'gui' : 'cterm'
  204              0.002926   let color = synIDattr(synIDtrans(hlID(a:group)), a:what, mode)
  204              0.001308   if empty(color) || color == -1
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, mode)
                              endif
  204              0.001174   if empty(color) || color == -1
                                if has('gui_running') || (has("termtruecolor") && &guicolors == 1)
                                  let color = a:what ==# 'fg' ? '#000000' : '#FFFFFF'
                                else
                                  let color = a:what ==# 'fg' ? 0 : 1
                                endif
                              endif
  204              0.000611   return color

FUNCTION  <SNR>102_Setup()
Called 1 time
Total time:   0.000362
 Self time:   0.000172

count  total (s)   self (s)
    1              0.000015     if index(g:indentLine_fileTypeExclude, &filetype) isnot -1
                                    return
                                endif
                            
    1              0.000011     if len(g:indentLine_fileType) isnot 0 && index(g:indentLine_fileType, &filetype) is -1
                                    return
                                end
                            
    1              0.000007     for name in g:indentLine_bufNameExclude
                                    if matchstr(bufname(''), name) is bufname('')
                                        return
                                    endif
                                endfor
                            
    1              0.000009     if ! exists("b:indentLine_bufNr")
    1              0.000011         let b:indentLine_bufNr = bufnr('%')
    1              0.000006         let g:indentLine_bufNr = bufnr('%')
    1              0.000005     elseif g:indentLine_bufNr != bufnr('%') && &hidden
                                    let g:indentLine_bufNr = bufnr('%')
                                    return
                                endif
                            
    1              0.000005     if &filetype ==# ""
    1   0.000188   0.000013         call s:InitColor()
    1              0.000002     endif
                            
    1              0.000004     if g:indentLine_enabled
    1   0.000025   0.000010         call s:IndentLinesEnable()
    1              0.000002     endif
                            
    1              0.000004     if g:indentLine_leadingSpaceEnabled
                                    call s:LeadingSpaceEnable()
                                endif

FUNCTION  367()
Called 6 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    6              0.000076   call add(self._sections, ['', a:text])

FUNCTION  ctrlp#utils#writecache()
Called 2 times
Total time:   0.010041
 Self time:   0.009941

count  total (s)   self (s)
    2   0.000154   0.000054 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    2              0.009863 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    2              0.000015 	en

FUNCTION  <SNR>39__skip_file()
Called 2 times
Total time:   0.000595
 Self time:   0.000315

count  total (s)   self (s)
    2              0.000023     let fname = expand('%', 1)
    2   0.000534   0.000254     let skip = s:_is_quitting(bufnr('%')) || get(b:, 'syntastic_skip_checks', 0) || (&buftype !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    2              0.000007     if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
    2              0.000005     return skip

FUNCTION  airline#themes#get_highlight()
Called 68 times
Total time:   0.019342
 Self time:   0.001220

count  total (s)   self (s)
   68   0.019272   0.001150   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  signature#sign#Refresh()
Called 1 time
Total time:   0.178684
 Self time:   0.000929

count  total (s)   self (s)
                              " Description: Add signs for new marks/markers and remove signs for deleted marks/markers
                              " Arguments: '1' to force a sign refresh
                            
    1   0.000492   0.000028   call s:InitializeVars()
                              " If Signature is not enabled, return
    1              0.000008   if !b:sig_enabled | return | endif
                            
   53   0.003567   0.000168   for i in signature#mark#GetList('free', 'buf_curr')
                                " ... remove it
   52   0.004924   0.000433     call signature#sign#Remove(i, 0)
   52              0.000113   endfor
                            
                              " Add signs for marks ...
    1   0.003099   0.000015   for j in signature#mark#GetList('used', 'buf_curr')
                                " ... if mark is not present in our b:sig_marks list or if it is present but at the wrong line,
                                " remove the old sign and add a new one
                                if !has_key(b:sig_marks, j[1]) || b:sig_marks[j[1]] !~# j[0] || a:0
                                  call signature#sign#Remove(j[0], 0   )
                                  call signature#sign#Place (j[0], j[1])
                                endif
                              endfor
                            
    1   0.166350   0.000032   call signature#sign#ToggleDummy()
                            
                              " We do not add signs for markers as SignRefresh is executed periodically and we don't have a way to determine if the
                              " marker already has a sign or not

FUNCTION  <SNR>20_init()
Called 3 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    3              0.000014   if s:airline_initialized
    3              0.000007     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:airline_theme_defined = exists('g:airline_theme')
                              if s:airline_theme_defined || !airline#switch_matching_theme()
                                let g:airline_theme = get(g:, 'airline_theme', 'dark')
                                call airline#switch_theme(g:airline_theme)
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  signature#utils#Maps()
Called 1 time
Total time:   0.002207
 Self time:   0.000356

count  total (s)   self (s)
                              " We create separate mappings for PlaceNextMark, mark#Purge('all') and PurgeMarkers instead of combining it with
                              " Leader/Input as if the user chooses to use some weird key like <BS> or <CR> for any of these 3, we need to be able
                              " to identify it. Eg. the nr2char(getchar()) will fail if the user presses a <BS>
    1              0.000015   let s:SignatureMapLeader = get(g:SignatureMap, 'Leader', 'm')
    1              0.000006   if (s:SignatureMapLeader == "")
                                echoe "Signature: g:SignatureMap.Leader shouldn't be left blank"
                              endif
    1   0.000197   0.000031   call s:Map(a:mode, 'Leader'           , s:SignatureMapLeader            , 'utils#Input()'                       )
    1   0.000113   0.000019   call s:Map(a:mode, 'PlaceNextMark'    , s:SignatureMapLeader . ","      , 'mark#Toggle("next")'                 )
    1   0.000103   0.000015   call s:Map(a:mode, 'ToggleMarkAtLine' , s:SignatureMapLeader . "."      , 'mark#ToggleAtLine()'                 )
    1   0.000103   0.000014   call s:Map(a:mode, 'PurgeMarksAtLine' , s:SignatureMapLeader . "-"      , 'mark#Purge("line")'                  )
    1   0.000101   0.000015   call s:Map(a:mode, 'PurgeMarks'       , s:SignatureMapLeader . "<Space>", 'mark#Purge("all")'                   )
    1   0.000098   0.000015   call s:Map(a:mode, 'PurgeMarkers'     , s:SignatureMapLeader . "<BS>"   , 'marker#Purge()'                      )
    1   0.000096   0.000014   call s:Map(a:mode, 'DeleteMark'       , "dm"                            , 'utils#Remove(v:count)'               )
    1   0.000098   0.000013   call s:Map(a:mode, 'GotoNextLineAlpha', "']"                            , 'mark#Goto("next", "line", "alpha")'  )
    1   0.000106   0.000017   call s:Map(a:mode, 'GotoPrevLineAlpha', "'["                            , 'mark#Goto("prev", "line", "alpha")'  )
    1   0.000096   0.000013   call s:Map(a:mode, 'GotoNextSpotAlpha', "`]"                            , 'mark#Goto("next", "spot", "alpha")'  )
    1   0.000096   0.000014   call s:Map(a:mode, 'GotoPrevSpotAlpha', "`["                            , 'mark#Goto("prev", "spot", "alpha")'  )
    1   0.000096   0.000013   call s:Map(a:mode, 'GotoNextLineByPos', "]'"                            , 'mark#Goto("next", "line", "pos")'    )
    1   0.000096   0.000012   call s:Map(a:mode, 'GotoPrevLineByPos', "['"                            , 'mark#Goto("prev", "line", "pos")'    )
    1   0.000098   0.000012   call s:Map(a:mode, 'GotoNextSpotByPos', "]`"                            , 'mark#Goto("next", "spot", "pos")'    )
    1   0.000093   0.000012   call s:Map(a:mode, 'GotoPrevSpotByPos', "[`"                            , 'mark#Goto("prev", "spot", "pos")'    )
    1   0.000097   0.000015   call s:Map(a:mode, 'GotoNextMarker'   , "]-"                            , 'marker#Goto("next", "same", v:count)')
    1   0.000094   0.000012   call s:Map(a:mode, 'GotoPrevMarker'   , "[-"                            , 'marker#Goto("prev", "same", v:count)')
    1   0.000098   0.000013   call s:Map(a:mode, 'GotoNextMarkerAny', "]="                            , 'marker#Goto("next", "any",  v:count)')
    1   0.000095   0.000013   call s:Map(a:mode, 'GotoPrevMarkerAny', "[="                            , 'marker#Goto("prev", "any",  v:count)')
    1   0.000092   0.000012   call s:Map(a:mode, 'ListLocalMarks'   , 'm/'                            , 'mark#List("buf_curr")'               )
    1   0.000094   0.000016   call s:Map(a:mode, 'ListLocalMarkers' , 'm?'                            , 'marker#List()'                       )

FUNCTION  syntastic#log#debug()
Called 24 times
Total time:   0.000920
 Self time:   0.000629

count  total (s)   self (s)
   24   0.000792   0.000501     if !s:_isDebugEnabled(a:level)
   24              0.000058         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  airline#util#exec_funcrefs()
Called 3 times
Total time:   0.005684
 Self time:   0.000524

count  total (s)   self (s)
   15              0.000058     for Fn in a:list
   15   0.005462   0.000302       let code = call(Fn, a:000)
   15              0.000047       if code != 0
    3              0.000009         return code
                                  endif
   12              0.000033     endfor
                                return 0

FUNCTION  airline#extensions#tabline#buffers#get()
Called 2 times
Total time:   0.010979
 Self time:   0.000935

count  total (s)   self (s)
    2              0.000126   let cur = bufnr('%')
    2              0.000023   if cur == s:current_bufnr
    1              0.000020     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    1              0.000006       return s:current_tabline
                                endif
                              endif
                            
    1              0.000005   let l:index = 1
    1   0.000459   0.000109   let b = airline#extensions#tabline#new_builder()
    1              0.000018   let tab_bufs = tabpagebuflist(tabpagenr())
    2   0.002400   0.000067   for nr in s:get_visible_buffers()
    1              0.000004     if nr < 0
                                  call b.add_raw('%#airline_tabhid#...')
                                  continue
                                endif
                            
    1              0.000004     if cur == nr
    1              0.000012       if g:airline_detect_modified && getbufvar(nr, '&modified')
                                    let group = 'airline_tabmod'
                                  else
    1              0.000006         let group = 'airline_tabsel'
    1              0.000002       endif
    1              0.000015       let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
    1              0.000003     else
                                  if g:airline_detect_modified && getbufvar(nr, '&modified')
                                    let group = 'airline_tabmod_unsel'
                                  elseif index(tab_bufs, nr) > -1
                                    let group = 'airline_tab'
                                  else
                                    let group = 'airline_tabhid'
                                  endif
                                endif
                            
    1              0.000007     if s:buffer_idx_mode
                                  if len(s:number_map) > 0
                                    call b.add_section(group, s:spc . get(s:number_map, l:index, '') . '%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)' . s:spc)
                                  else
                                    call b.add_section(group, '['.l:index.s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)'.']')
                                  endif
                                  let l:index = l:index + 1
                                else
    1   0.000058   0.000027       call b.add_section(group, s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.nr.')}%)'.s:spc)
    1              0.000002     endif
    1              0.000002   endfor
                            
    1   0.000070   0.000027   call b.add_section('airline_tabfill', '')
    1   0.000046   0.000015   call b.split()
    1   0.000045   0.000017   call b.add_section('airline_tabfill', '')
    1              0.000009   if s:show_tab_type
    1   0.000043   0.000017     call b.add_section('airline_tabtype', ' buffers ')
    1              0.000004   endif
                            
    1              0.000011   let s:current_bufnr = cur
    1   0.007224   0.000021   let s:current_tabline = b.build()
    1              0.000004   return s:current_tabline

FUNCTION  <SNR>129_lash()
Called 2 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000047 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  <SNR>105__isDebugEnabled_smart()
Called 28 times
Total time:   0.000379
 Self time:   0.000379

count  total (s)   self (s)
   28              0.000346     return and(g:syntastic_debug, a:level)

FUNCTION  airline#extensions#default#apply()
Called 3 times
Total time:   0.004113
 Self time:   0.000414

count  total (s)   self (s)
    3              0.000020   let winnr = a:context.winnr
    3              0.000016   let active = a:context.active
                            
    3   0.000083   0.000049   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    3   0.001640   0.000065     call s:build_sections(a:builder, a:context, s:layout[0])
    3              0.000007   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
    3   0.000355   0.000063   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    3   0.000058   0.000032   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    3   0.001820   0.000048     call s:build_sections(a:builder, a:context, s:layout[1])
    3              0.000006   endif
                            
    3              0.000007   return 1

FUNCTION  <SNR>25_Map()
Called 21 times
Total time:   0.001851
 Self time:   0.001851

count  total (s)   self (s)
   21              0.000212   let l:map_lhs = get(g:SignatureMap, a:key, a:map_lhs_default)
   21              0.000085   if (l:map_lhs ==? '')
                                return
                              endif
   21              0.000089   if (a:mode ==? 'create')
   21              0.001152     silent! execute 'nnoremap <silent> <unique> ' . l:map_lhs . ' ' . ':<C-U>call signature#' . a:map_rhs . '<CR>'
   21              0.000070   elseif (a:mode ==? 'remove')
                                silent! execute 'nunmap ' . l:map_lhs
                              endif

FUNCTION  364()
Called 4 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    4              0.000076   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>52_chop()
Called 2 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    2              0.000049 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    2              0.000007 	retu a:mrufs

FUNCTION  368()
Called 4 times
Total time:   0.038874
 Self time:   0.005185

count  total (s)   self (s)
    4              0.000021   let side = 1
    4              0.000017   let line = ''
    4              0.000017   let i = 0
    4              0.000034   let length = len(self._sections)
    4              0.000017   let split = 0
                            
   39              0.000172   while i < length
   35              0.000256     let section = self._sections[i]
   35              0.000203     let group = section[0]
   35              0.000196     let contents = section[1]
   35   0.001828   0.000505     let prev_group = s:get_prev_group(self._sections, i)
                            
   35              0.000132     if group == ''
    6              0.000037       let line .= contents
    6              0.000019     elseif group == '|'
    4              0.000013       let side = 0
    4              0.000022       let line .= contents
    4              0.000014       let split = 1
    4              0.000008     else
   25              0.000101       if prev_group == ''
    4              0.000042         let line .= '%#'.group.'#'
    4              0.000014       elseif split
    4   0.003442   0.000071         let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    4              0.000015         let split = 0
    4              0.000009       else
   17   0.025528   0.000306         let line .= s:get_seperator(self, prev_group, group, side)
   17              0.000038       endif
   25   0.004268   0.000496       let line .= s:get_accented_line(self, group, contents)
   25              0.000051     endif
                            
   35              0.000200     let i = i + 1
   35              0.000090   endwhile
                            
    4              0.000018   if !self._context.active
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
    4              0.000013   return line

FUNCTION  <SNR>102_IndentLinesEnable()
Called 2 times
Total time:   0.000534
 Self time:   0.000474

count  total (s)   self (s)
    2              0.000022     if exists("b:indentLine_enabled") && b:indentLine_enabled
    1              0.000003         return
                                else
    1              0.000006         let b:indentLine_enabled = 1
    1              0.000002     endif
    1   0.000086   0.000026     call s:SetConcealOption()
                            
    1              0.000010     let space = &l:shiftwidth is 0 ? &l:tabstop : &l:shiftwidth
                            
    1              0.000004     if g:indentLine_showFirstIndentLevel
                                    execute 'syntax match IndentLine /^ / containedin=ALL conceal cchar=' . g:indentLine_first_char
                                endif
                            
    1              0.000004     if g:indentLine_faster
                                    execute 'syntax match IndentLineSpace /^\s\+/ containedin=ALL contains=IndentLine'
                                    execute 'syntax match IndentLine / \{'.(space-1).'}\zs / contained conceal cchar=' . g:indentLine_char
                                    execute 'syntax match IndentLine /\t\zs / contained conceal cchar=' . g:indentLine_char
                                else
    1              0.000011         let pattern = line('$') < g:indentLine_maxLines ? 'v' : 'c'
   11              0.000045         for i in range(space+1, space * g:indentLine_indentLevel + 1, space)
   10              0.000260             execute 'syntax match IndentLine /\%(^\s\+\)\@<=\%'.i.pattern.' / containedin=ALL conceal cchar=' . g:indentLine_char
   10              0.000024         endfor
    1              0.000002     endif

FUNCTION  xolox#misc#path#decode()
Called 8 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
                              " Decode a pathname previously encoded with `xolox#misc#path#encode()`.
    8              0.000111   return substitute(a:encoded_path, '%\(\x\x\?\)', '\=nr2char("0x" . submatch(1))', 'g')

FUNCTION  signature#sign#Remove()
Called 52 times
Total time:   0.004491
 Self time:   0.004491

count  total (s)   self (s)
                              " Description: Remove signs for marks/markers from the specified line number
                              " Arguments:
                              "   sign : The mark/marker whose sign is to be placed/removed/toggled
                              "   lnum : Line number from which the sign is to be removed
                              "          If line number is 0, the 'sign' will be removed from all lines
                            
                              "echom "DEBUG: sign = " . a:sign . ",  lnum = " . a:lnum
                            
                              " If Signature is not enabled, return
   52              0.000355   if !b:sig_enabled | return | endif
                            
                              " Remove sign for markers
   52              0.000402   if stridx( b:SignatureIncludeMarkers, a:sign ) >= 0
                                let b:sig_markers[a:lnum] = substitute(b:sig_markers[a:lnum], "\\C" . escape( a:sign, '$^' ), "", "")
                            
                                " If there are no markers on the line, delete signs on that line
                                if b:sig_markers[a:lnum] == ""
                                  call remove(b:sig_markers, a:lnum)
                                endif
                                call s:RefreshLine(a:lnum)
                            
                              " Remove sign for marks
                              else
                                " If a:lnum == 0, remove from all lines
   52              0.000161     if a:lnum == 0
   52              0.001060       let l:arr = keys(filter(copy(b:sig_marks), 'v:val =~# a:sign'))
   52              0.000299       if empty(l:arr) | return | endif
                                else
                                  let l:arr = [a:lnum]
                                endif
                            
                                for l:lnum in l:arr
                                  " FIXME: Placed guard to avoid triggering issue #53
                                  if has_key(b:sig_marks, l:lnum)
                                    let b:sig_marks[l:lnum] = substitute(b:sig_marks[l:lnum], "\\C" . a:sign, "", "")
                                    " If there are no marks on the line, delete signs on that line
                                    if b:sig_marks[l:lnum] == ""
                                      call remove(b:sig_marks, l:lnum)
                                    endif
                                  endif
                                  call s:RefreshLine(l:lnum)
                                endfor
                              endif

FUNCTION  <SNR>112_update()
Called 6 times
Total time:   0.000372
 Self time:   0.000372

count  total (s)   self (s)
    6              0.000283   if &ft !~ s:filetypes
    6              0.000046     unlet! b:airline_wordcount
    6              0.000021     return
                              endif
                            
                              let old_status = v:statusmsg
                              let position = getpos(".")
                              exe "silent normal! g\<c-g>"
                              let stat = v:statusmsg
                              call setpos('.', position)
                              let v:statusmsg = old_status
                            
                              let parts = split(stat)
                              if len(parts) > 11
                                let cnt = str2nr(split(stat)[11])
                                let spc = g:airline_symbols.space
                                let b:airline_wordcount = cnt . spc . 'words' . spc . g:airline_right_alt_sep . spc
                              else
                                unlet! b:airline_wordcount
                              endif

FUNCTION  airline#parts#iminsert()
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000013   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
    2              0.000004   return ''

FUNCTION  <SNR>56_FindFileTarget()
Called 1 time
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000005     let target = a:target
    1              0.000004     let i = 0
    1              0.000007     let numItems = len(s:Dict)
    1              0.000006     while i < numItems
    1              0.000005         if i != s:EasyGrepModeTracked
    1              0.000025             let patterns = split(s:Dict[i][1])
    1              0.000006             for p in patterns
    1              0.000005                 if target ==# p
    1              0.000003                     return i
                                            endif
                                        endfor
                                    endif
                                    let i += 1
                                endwhile
                                return -1

FUNCTION  <SNR>102_ResetWidth()
Called 1 time
Total time:   0.000687
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000005     if 0 < a:0
                                    let &l:shiftwidth = a:1
                                endif
                            
    1   0.000122   0.000032     call s:IndentLinesDisable()
    1   0.000549   0.000031     call s:IndentLinesEnable()

FUNCTION  xolox#misc#path#join()
Called 1 time
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
                              " Join a list of pathname components (the first and only argument) into a
                              " single pathname string. This is the counterpart to the
                              " `xolox#misc#path#split()` function and it expects a list of pathname
                              " components as returned by `xolox#misc#path#split()`.
    1              0.000008   if type(a:parts) == type([])
    1              0.000004     if s:windows_compatible
                                  return join(a:parts, xolox#misc#path#directory_separator())
                                elseif get(a:parts, 0) == '/'
                                  " Absolute path on UNIX (non-Windows).
    1              0.000021       return '/' . join(a:parts[1:], '/')
                                else
                                  " Relative path on UNIX (non-Windows).
                                  return join(a:parts, '/')
                                endif
                              endif
                              return ''

FUNCTION  303()
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000020     let newObj = copy(self)
    1              0.000010     let newObj._flags = {}
    1              0.000005     return newObj

FUNCTION  airline#extensions#tabline#buflist#list()
Called 3 times
Total time:   0.000662
 Self time:   0.000662

count  total (s)   self (s)
    3              0.000038   if exists('s:current_buffer_list')
    2              0.000009     return s:current_buffer_list
                              endif
                            
    1              0.000008   let buffers = []
    1              0.000012   let cur = bufnr('%')
    4              0.000033   for nr in range(1, bufnr('$'))
    3              0.000037     if buflisted(nr) && bufexists(nr)
    1              0.000007       let toadd = 1
    1              0.000008       for ex in s:excludes
                                    if match(bufname(nr), ex) >= 0
                                      let toadd = 0
                                      break
                                    endif
                                  endfor
    1              0.000016       if getbufvar(nr, 'current_syntax') == 'qf'
                                    let toadd = 0
                                  endif
    1              0.000025       if s:exclude_preview && getbufvar(nr, '&bufhidden') == 'wipe' && getbufvar(nr, '&buftype') == 'nofile'
                                    let toadd = 0
                                  endif
    1              0.000005       if toadd
    1              0.000029         call add(buffers, nr)
    1              0.000003       endif
    1              0.000003     endif
    3              0.000017   endfor
                            
    1              0.000015   let s:current_buffer_list = buffers
    1              0.000007   return buffers

FUNCTION  <SNR>122_get_transitioned_seperator()
Called 21 times
Total time:   0.017939
 Self time:   0.001246

count  total (s)   self (s)
   21              0.000084   let line = ''
   21   0.017034   0.000340   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   21              0.000313   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   21              0.000238   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   21              0.000137   let line .= '%#'.a:group.'#'
   21              0.000067   return line

FUNCTION  syntastic#util#stamp()
Called 3 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
    3              0.000151     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  xolox#misc#path#merge()
Called 1 time
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
                              " Join a directory pathname and filename into a single pathname.
    1              0.000013   if type(a:parent) == type('') && type(a:child) == type('')
                                " TODO Use xolox#misc#path#is_relative()?
    1              0.000004     if s:windows_compatible
                                  let parent = substitute(a:parent, '[\\/]\+$', '', '')
                                  let child = substitute(a:child, '^[\\/]\+', '', '')
                                  return parent . '\' . child
                                else
    1              0.000018       let parent = substitute(a:parent, '/\+$', '', '')
    1              0.000012       let child = substitute(a:child, '^/\+', '', '')
    1              0.000006       return parent . '/' . child
                                endif
                              endif
                              return ''

FUNCTION  <SNR>56_DoCollectEnabledFileTargets()
Called 1 time
Total time:   0.000176
 Self time:   0.000163

count  total (s)   self (s)
    1              0.000008     if s:traversed[a:key] == 1
                                    return []
                                endif
    1              0.000008     let s:traversed[a:key] = 1
                            
    1              0.000003     let lst = []
    1              0.000017     let fileTargetList = split(s:Dict[a:key][1])
    2              0.000008     for p in fileTargetList
    1   0.000036   0.000022         if s:IsLink(p)
                                        let k = s:FindTargetByKey(s:GetKeyFromLink(p))
                                        if k != -1
                                            call extend(lst, s:DoCollectEnabledFileTargets(k))
                                        endif
                                    else
    1              0.000019             call add(lst, p)
    1              0.000002         endif
    1              0.000002     endfor
    1              0.000003     return lst

FUNCTION  312()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000015     return exists("b:NERDTree")

FUNCTION  317()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000009     if exists("t:NERDTreeBufName")
                                    return bufwinnr(t:NERDTreeBufName)
                                endif
                            
    1              0.000003     return -1

FUNCTION  318()
Called 1 time
Total time:   0.000043
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000041   0.000019     return s:NERDTree.GetWinNum() != -1

FUNCTION  syntastic#log#debugShowOptions()
Called 1 time
Total time:   0.000024
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000020   0.000012     if !s:_isDebugEnabled(a:level)
    1              0.000002         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  xolox#session#auto_save()
Called 1 time
Total time:   0.004907
 Self time:   0.001305

count  total (s)   self (s)
                              " Automatically save the current editing session when Vim is closed.
                              " Normally called by the [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1              0.000008   if v:dying
                                " We won't save the session if Vim is not terminating normally.
                                return
                              endif
    1              0.000009   if g:session_autosave == 'no'
                                " We won't save the session if auto-save is explicitly disabled.
                                return
                              endif
                              " Get the name of the session for automatic saving.
    1   0.001543   0.001094   let name = xolox#misc#option#get('session_autosave_to')
    1              0.000006   if empty(name)
                                " Get the name of the active session (if any).
    1   0.000191   0.000037     let name = xolox#session#find_current_session()
                                " If no session is active and the user doesn't have any sessions yet,
                                " help them get started by suggesting to create the default session.
    1   0.003037   0.000037     if empty(name) && (empty(xolox#session#get_names(0)) || g:session_default_overwrite)
                                  let name = g:session_default_name
                                endif
    1              0.000002   endif
                              " Prompt the user to save the active/first/default session?
    1              0.000006   if !empty(name)
                                let is_tab_scoped = xolox#session#is_tab_scoped()
                                let msg = "Do you want to save your %s before quitting Vim?"
                                if s:prompt(printf(msg, xolox#session#get_label(name, is_tab_scoped)), ["&Save", "&Don't Save"], 'g:session_autosave') == 1
                                  if g:session_default_overwrite && (name == g:session_default_name)
                                    let bang = '!'
                                  else
                                    let bang = ''
                                  endif
                                  if is_tab_scoped
                                    call xolox#session#save_tab_cmd(name, bang, 'SaveTabSession')
                                  else
                                    call xolox#session#save_cmd(name, bang, 'SaveSession')
                                  endif
                                endif
                              endif

FUNCTION  <SNR>123_build_sections()
Called 6 times
Total time:   0.003348
 Self time:   0.000742

count  total (s)   self (s)
   27              0.000088   for key in a:keys
   21              0.000115     if key == 'warning' && !a:context.active
                                  continue
                                endif
   21   0.002870   0.000264     call s:add_section(a:builder, a:context, key)
   21              0.000045   endfor

FUNCTION  111()
Called 1 time
Total time:   0.294817
 Self time:   0.017827

count  total (s)   self (s)
    1   0.294816   0.017826     exec "edit " . self.str({'format': 'Edit'})

FUNCTION  112()
Called 1 time
Total time:   0.000086
 Self time:   0.000065

count  total (s)   self (s)
    1   0.000040   0.000019     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
    1              0.000008         let self.drive = ''
    1              0.000002     endif
                            

FUNCTION  114()
Called 1 time
Total time:   0.000036
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000025   0.000006     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>"
                                endif
                            
    1              0.000004     return " \\`\|\"#%&,?()\*^<>[]"

FUNCTION  117()
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000007     if empty(self.pathSegments)
                                    return ''
                                endif
    1              0.000009     let toReturn = self.pathSegments[-1]
    1              0.000005     if a:dirSlash && self.isDirectory
                                    let toReturn = toReturn . '/'
                                endif
    1              0.000003     return toReturn

FUNCTION  <SNR>107_is_excluded_window()
Called 3 times
Total time:   0.000377
 Self time:   0.000377

count  total (s)   self (s)
    3              0.000019   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   12              0.000042   for matchw in g:airline_exclude_filenames
    9              0.000140     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
    9              0.000018   endfor
                            
    3              0.000014   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    3              0.000007   return 0

FUNCTION  320()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006     return self._type == "window"

FUNCTION  329()
Called 1 time
Total time:   0.003427
 Self time:   0.000728

count  total (s)   self (s)
    1              0.000014     let line = getline(a:ln)
                            
    1   0.000148   0.000028     let rootLine = self.getRootLineNum()
                            
                                "check to see if we have the root node
    1              0.000006     if a:ln == rootLine
                                    return self.nerdtree.root.path
                                endif
                            
    1   0.000022   0.000016     if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
                                endif
                            
    1   0.000093   0.000017     let indent = self._indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
    1   0.000241   0.000020     let curFile = self._stripMarkup(line, 0)
                            
    1              0.000004     let wasdir = 0
    1              0.000006     if curFile =~# '/$'
                                    let wasdir = 1
                                    let curFile = substitute(curFile, '/\?$', '/', "")
                                endif
                            
    1              0.000004     let dir = ""
    1              0.000005     let lnum = a:ln
    6              0.000020     while lnum > 0
    6              0.000033         let lnum = lnum - 1
    6              0.000041         let curLine = getline(lnum)
    6   0.001103   0.000073         let curLineStripped = self._stripMarkup(curLine, 1)
                            
                                    "have we reached the top of the tree?
    6              0.000022         if lnum == rootLine
    1   0.000248   0.000033             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
    1              0.000003             break
                                    endif
    5              0.000033         if curLineStripped =~# '/$'
                                        let lpindent = self._indentLevelFor(curLine)
                                        if lpindent < indent
                                            let indent = indent - 1
                            
                                            let dir = substitute (curLineStripped,'^\\', "", "") . dir
                                            continue
                                        endif
                                    endif
    5              0.000015     endwhile
    1              0.000011     let curFile = self.nerdtree.root.path.drive . dir . curFile
    1   0.001058   0.000028     let toReturn = g:NERDTreePath.New(curFile)
    1              0.000011     return toReturn

FUNCTION  signature#sign#ToggleDummy()
Called 1 time
Total time:   0.166318
 Self time:   0.166318

count  total (s)   self (s)
                              " Description: Places a dummy sign to prevent flickering of the gutter when the mark is moved or the line containing
                              "              a mark/marker is deleted and then the delete is undone
                              " Arguments:   a:1 (place/remove) - Force mode
                            
    1              0.000004   if (a:0)
                                let l:place  = (a:1 =~# 'place' )
                                let l:remove = (a:1 =~# 'remove')
                              else
    1              0.000014     let l:place  = (len(b:sig_marks) + len(b:sig_markers) == 1)
    1              0.000011     let l:remove = (len(b:sig_marks) + len(b:sig_markers) == 0)
    1              0.000002   endif
                            
    1              0.000004   if (l:place)
                                sign define Signature_Dummy
                                execute 'sign place 666 line=1 name=Signature_Dummy buffer=' . bufnr('%')
                              elseif (l:remove)
    1              0.166235     silent! execute 'sign unplace 666 buffer=' . bufnr('%')
    1              0.000011   endif

FUNCTION  30()
Called 4 times
Total time:   0.000126
 Self time:   0.000037

count  total (s)   self (s)
    4   0.000122   0.000033     return syntastic#util#var('echo_current_error')

FUNCTION  31()
Called 2 times
Total time:   0.000162
 Self time:   0.000090

count  total (s)   self (s)
    2   0.000096   0.000024     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  32()
Called 1 time
Total time:   0.000054
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000030   0.000011     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    1              0.000010     autocmd! syntastic CursorMoved
    1              0.000005     unlet! b:syntastic_private_messages
    1              0.000006     let b:syntastic_private_line = -1

FUNCTION  34()
Called 4 times
Total time:   0.000143
 Self time:   0.000047

count  total (s)   self (s)
    4   0.000138   0.000043     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  35()
Called 2 times
Total time:   0.000458
 Self time:   0.000289

count  total (s)   self (s)
    2   0.000080   0.000014     if self.enabled()
    2   0.000066   0.000024         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    2   0.000064   0.000016         call self._reset()
    2              0.000014         let buf = bufnr('')
    2   0.000068   0.000054         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    2              0.000009         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    2              0.000004     endif

FUNCTION  36()
Called 1 time
Total time:   0.000079
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000005     if s:has_highlighting
    1   0.000034   0.000012         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    1   0.000035   0.000010         call self._reset()
    1              0.000002     endif

FUNCTION  38()
Called 3 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    3              0.000021     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor

FUNCTION  39()
Called 2 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
    2              0.000054     let newObj = copy(self)
                            
    2              0.000038     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
    2              0.000010     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
    2              0.000013     let newObj._rawLoclist = llist
    2              0.000009     let newObj._name = ''
    2              0.000014     let newObj._owner = bufnr('')
    2              0.000008     let newObj._sorted = 0
    2              0.000013     let newObj._columns = g:syntastic_cursor_columns
                            
    2              0.000006     return newObj

FUNCTION  <SNR>39_BufEnterHook()
Called 1 time
Total time:   0.001996
 Self time:   0.000137

count  total (s)   self (s)
    1   0.000087   0.000053     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))) . ', &buftype = ' . string(&buftype))
    1              0.000005     if &buftype ==# ''
    1   0.001845   0.000021         call s:notifiers.refresh(g:SyntasticLoclist.current())
    1              0.000004     elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"] == 1')
                                    let owner = str2nr(getbufvar(bufnr(''), 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if get(w:, 'syntastic_loclist_set', 0) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif

FUNCTION  ctrlp#mrufiles#cachefile()
Called 2 times
Total time:   0.001491
 Self time:   0.000816

count  total (s)   self (s)
    2              0.000023 	if !exists('s:cadir') || !exists('s:cafile')
    1   0.001415   0.000751 		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
    1   0.000023   0.000013 		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
    1              0.000002 	en
    2              0.000008 	retu s:cafile

FUNCTION  127()
Called 10 times
Total time:   0.004770
 Self time:   0.000136

count  total (s)   self (s)
   10   0.004760   0.000126     return self.str() ==# a:path.str()

FUNCTION  128()
Called 1 time
Total time:   0.001030
 Self time:   0.000226

count  total (s)   self (s)
    1              0.000070     let newPath = copy(self)
                            
    1   0.000799   0.000034     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
    1              0.000009     let newPath.cachedDisplayString = ""
    1   0.000072   0.000034     let newPath.flagSet = g:NERDTreeFlagSet.New()
                            
    1              0.000072     return newPath

FUNCTION  129()
Called 54 times
Total time:   0.001451
 Self time:   0.000431

count  total (s)   self (s)
   54   0.001409   0.000389     return nerdtree#runningWindows() ? '\' : '/'

FUNCTION  331()
Called 1 time
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    1              0.000008     let rootLine = 1
    4              0.000067     while getline(rootLine) !~# '^\(/\|<\)'
    3              0.000019         let rootLine = rootLine + 1
    3              0.000008     endwhile
    1              0.000005     return rootLine

FUNCTION  <SNR>39_BufReadPostHook()
Called 1 time
Total time:   0.006312
 Self time:   0.000181

count  total (s)   self (s)
    1              0.000005     if g:syntastic_check_on_open
    1   0.000408   0.000130         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . bufnr('') . ' = ' . string(bufname(str2nr(bufnr('')))))
    1   0.005892   0.000040         call s:UpdateErrors(1, [])
    1              0.000002     endif

FUNCTION  337()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     return 2

FUNCTION  nerdtree#checkForBrowse()
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000022     if a:dir != '' && isdirectory(a:dir)
                                    call g:NERDTreeCreator.CreateWindowTree(a:dir)
                                endif

FUNCTION  40()
Called 5 times
Total time:   0.000267
 Self time:   0.000154

count  total (s)   self (s)
    5              0.000065     if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
    1   0.000132   0.000019         let b:syntastic_loclist = g:SyntasticLoclist.New([])
    1              0.000002     endif
    5              0.000021     return b:syntastic_loclist

FUNCTION  43()
Called 9 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    9              0.000048     return empty(self._rawLoclist)

FUNCTION  44()
Called 2 times
Total time:   0.000230
 Self time:   0.000082

count  total (s)   self (s)
    2              0.000014     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
    2   0.000197   0.000049     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  45()
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000012     return copy(self._rawLoclist)

FUNCTION  46()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return self._rawLoclist

FUNCTION  47()
Called 2 times
Total time:   0.000240
 Self time:   0.000086

count  total (s)   self (s)
    2   0.000238   0.000083     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  49()
Called 2 times
Total time:   0.000396
 Self time:   0.000396

count  total (s)   self (s)
    2              0.000016     if !exists('self._stl_format')
    1              0.000008         let self._stl_format = ''
    1              0.000002     endif
    2              0.000012     if !exists('self._stl_flag')
    1              0.000005         let self._stl_flag = ''
    1              0.000002     endif
                            
    2              0.000013     if g:syntastic_stl_format !=# self._stl_format
    1              0.000006         let self._stl_format = g:syntastic_stl_format
                            
    1              0.000006         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
    1              0.000006             let self._stl_flag = ''
    1              0.000002         endif
    1              0.000002     endif
                            
    2              0.000008     return self._stl_flag

FUNCTION  130()
Called 2 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
    2              0.000056     let tmp = resolve(a:path)
    2              0.000055     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  131()
Called 1 time
Total time:   0.000661
 Self time:   0.000366

count  total (s)   self (s)
    1   0.000101   0.000015     call self.extractDriveLetter(a:fullpath)
                            
    1   0.000050   0.000016     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
    1              0.000042     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
    1              0.000022     let self.pathSegments = split(fullpath, '/')
                            
    1              0.000006     let self.isReadOnly = 0
    1              0.000015     if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
                                elseif filereadable(a:fullpath)
    1              0.000007         let self.isDirectory = 0
    1              0.000028         let self.isReadOnly = filewritable(a:fullpath) ==# 0
    1              0.000002     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
    1              0.000007     let self.isExecutable = 0
    1              0.000004     if !self.isDirectory
    1              0.000018         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    1              0.000002     endif
                            
                                "grab the last part of the path (minus the trailing slash)
    1   0.000055   0.000018     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
    1   0.000117   0.000031     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
    1   0.000073   0.000021     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
    1              0.000004     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  <SNR>56_CheckDefaultUserPattern()
Called 1 time
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
    1              0.000004     let error = ""
    1              0.000014     let userModeAndEmpty = (g:EasyGrepMode == s:EasyGrepModeUser) && empty(s:Dict[s:EasyGrepModeUser][1])
    1              0.000007     if exists("g:EasyGrepDefaultUserPattern")
                                    if empty(g:EasyGrepDefaultUserPattern) && userModeAndEmpty
                                        let error = "Cannot start in 'User' mode when g:EasyGrepDefaultUserPattern is empty"
                                        call s:ForceGrepMode(s:EasyGrepModeAll)
                                    elseif s:IsRecursivePattern(g:EasyGrepDefaultUserPattern)
                                        let error = "User specified grep pattern may not have a recursive specifier"
                                    else
                                        let s:Dict[s:EasyGrepModeUser][1] = g:EasyGrepDefaultUserPattern
                                    endif
                                elseif userModeAndEmpty
                                    let error = "Cannot start in 'User' mode when g:EasyGrepDefaultUserPattern is undefined"
                                    call s:ForceGrepMode(s:EasyGrepModeAll)
                                endif
                            
    1              0.000005     if !empty(error)
                                    let error = error."; switching to 'All' mode"
                                    call EasyGrep#Error(error)
                                    call s:ForceGrepMode(s:EasyGrepModeAll)
                                endif

FUNCTION  135()
Called 29 times
Total time:   0.007104
 Self time:   0.003224

count  total (s)   self (s)
   29              0.000161     let options = a:0 ? a:1 : {}
   29              0.000112     let toReturn = ""
                            
   29              0.000157     if has_key(options, 'format')
    2              0.000013         let format = options['format']
    2              0.000017         if has_key(self, '_strFor' . format)
    2   0.000091   0.000054             exec 'let toReturn = self._strFor' . format . '()'
    2              0.000005         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
    2              0.000004     else
   27   0.003253   0.000232         let toReturn = self._str()
   27              0.000054     endif
                            
   29   0.000512   0.000257     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
   29              0.000152     if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if len(toReturn) > limit-1
                                        let toReturn = toReturn[(len(toReturn)-limit+1):]
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
                                endif
                            
   29              0.000086     return toReturn

FUNCTION  136()
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000016     let toReturn = '/' . join(self.pathSegments, '/')
    1              0.000007     if self.isDirectory && toReturn != '/'
    1              0.000006         let toReturn  = toReturn . '/'
    1              0.000002     endif
    1              0.000003     return toReturn

FUNCTION  138()
Called 1 time
Total time:   0.000422
 Self time:   0.000121

count  total (s)   self (s)
    1   0.000345   0.000043     let p = escape(self.str(), self._escChars())
                            
                                "make it relative
    1              0.000043     let p = fnamemodify(p, ':.')
                            
                                "handle the edge case where the file begins with a + (vim interprets
                                "the +foo in `:e +foo` as an option to :edit)
    1              0.000008     if p[0] == "+"
                                    let p = '\' . p
                                endif
                            
    1              0.000004     if p ==# ''
                                    let p = '.'
                                endif
                            
    1              0.000003     return p

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 2 times
Total time:   0.001469
 Self time:   0.000595

count  total (s)   self (s)
    2   0.001464   0.000590   return airline#extensions#tabline#formatters#{s:formatter}#format(a:nr, airline#extensions#tabline#buflist#list())

FUNCTION  ctrlp#utils#readfile()
Called 2 times
Total time:   0.000901
 Self time:   0.000901

count  total (s)   self (s)
    2              0.000091 	if filereadable(a:file)
    2              0.000753 		let data = readfile(a:file)
    2              0.000024 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    2              0.000007 		retu data
                            	en
                            	retu []

FUNCTION  340()
Called 7 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
    7              0.000101     return '^\(['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+\)'

FUNCTION  345()
Called 7 times
Total time:   0.001252
 Self time:   0.001143

count  total (s)   self (s)
    7              0.000032     let line = a:line
                                "remove the tree parts and the leading space
    7   0.000336   0.000227     let line = substitute (line, g:NERDTreeUI.MarkupReg(),"","")
                            
                                "strip off any read only flag
    7              0.000083     let line = substitute (line, ' \[RO\]', "","")
                            
                                "strip off any bookmark flags
    7              0.000076     let line = substitute (line, ' {[^}]*}', "","")
                            
                                "strip off any executable flags
    7              0.000079     let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                "strip off any generic flags
    7              0.000072     let line = substitute (line, '\[[^]]*\]', "","")
                            
    7              0.000025     let wasdir = 0
    7              0.000057     if line =~# '/$'
    1              0.000004         let wasdir = 1
    1              0.000002     endif
    7              0.000082     let line = substitute (line,' -> .*',"","") " remove link to
    7              0.000025     if wasdir ==# 1
    1              0.000024         let line = substitute (line, '/\?$', '/', "")
    1              0.000002     endif
                            
    7              0.000030     if a:removeLeadingSpaces
    6              0.000084         let line = substitute (line, '^ *', '', '')
    6              0.000012     endif
                            
    7              0.000021     return line

FUNCTION  <SNR>52_record()
Called 3 times
Total time:   0.010015
 Self time:   0.000334

count  total (s)   self (s)
    3              0.000035 	if s:exclnomod && &l:modifiable | retu | en
    3              0.000021   if s:exclnomod && !&l:modifiable | retu | en
    3              0.000019 	if s:locked | retu | en
    3              0.000023 	let bufnr = a:bufnr + 0
    3              0.000026 	let bufname = bufname(bufnr)
    3              0.000025 	if bufnr > 0 && !empty(bufname)
    3              0.000070 		cal filter(s:mrbs, 'v:val != bufnr')
    3              0.000034 		cal insert(s:mrbs, bufnr)
    3   0.009738   0.000057 		cal s:addtomrufs(bufname)
    3              0.000006 	en

FUNCTION  <SNR>107_sync_active_winnr()
Called 5 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
    5              0.000105   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  54()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000014     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  55()
Called 1 time
Total time:   0.000261
 Self time:   0.000080

count  total (s)   self (s)
    1   0.000030   0.000014     call self.setOwner(bufnr(''))
    1   0.000077   0.000023     let self._stamp = syntastic#util#stamp()
    2   0.000129   0.000017     for buf in self.getBuffers()
    1              0.000013         call setbufvar(buf, 'syntastic_loclist', self)
    1              0.000002     endfor

FUNCTION  56()
Called 1 time
Total time:   0.000172
 Self time:   0.000044

count  total (s)   self (s)
    2   0.000147   0.000019     for buf in self.getBuffers()
    1              0.000014         call setbufvar(buf, 'syntastic_loclist', {})
    1              0.000002     endfor

FUNCTION  140()
Called 27 times
Total time:   0.003021
 Self time:   0.001071

count  total (s)   self (s)
   27   0.000967   0.000226     let lead = s:Path.Slash()
                            
                                "if we are running windows then slap a drive letter on the front
   27   0.000680   0.000181     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
                                endif
                            
   27   0.001110   0.000399     return lead . join(self.pathSegments, s:Path.Slash())

FUNCTION  141()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000022     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  142()
Called 1 time
Total time:   0.000410
 Self time:   0.000158

count  total (s)   self (s)
    1   0.000262   0.000010     let str = self.str()
    2              0.000015     for t in range(tabpagenr('$'))
    2              0.000013         for b in tabpagebuflist(t+1)
    1              0.000073             if str == expand('#' . b . ':p')
                                            return t+1
                                        endif
    1              0.000003         endfor
    1              0.000002     endfor
    1              0.000003     return 0

FUNCTION  143()
Called 1 time
Total time:   0.000034
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000027   0.000008     if !nerdtree#runningWindows()
    1              0.000004         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  <SNR>8_SelectJavascript()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000016   if getline(1) =~# '^#!.*/bin/env\s\+node\>'
                                set ft=javascript
                              endif

FUNCTION  354()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return '.. (up a dir)'

FUNCTION  airline#extensions#tabline#new_builder()
Called 1 time
Total time:   0.000350
 Self time:   0.000216

count  total (s)   self (s)
    1              0.000072   let builder_context = { 'active'        : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    1              0.000015   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
                              else
    1              0.000022     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
    1              0.000022     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    1              0.000004   endif
                            
    1   0.000171   0.000038   return airline#builder#new(builder_context)

FUNCTION  <SNR>39_UpdateErrors()
Called 1 time
Total time:   0.005852
 Self time:   0.000768

count  total (s)   self (s)
    1   0.000199   0.000090     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    1   0.000137   0.000113     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, s:_DEBUG_DUMP_OPTIONS)
    1   0.000076   0.000025     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    1   0.000178   0.000106     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    1   0.000211   0.000071     call s:modemap.synch()
                            
    1   0.000379   0.000037     if s:_skip_file()
                                    return
                                endif
                            
    1   0.000163   0.000027     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking()
    1              0.000004     if run_checks
    1   0.002392   0.000029         call s:CacheErrors(a:checker_names)
    1              0.000006         unlockvar! b:syntastic_changedtick
    1              0.000007         let b:syntastic_changedtick = b:changedtick
    1              0.000006         lockvar! b:syntastic_changedtick
    1              0.000002     else
                                    if a:auto_invoked
                                        return
                                    endif
                                endif
                            
    1   0.000037   0.000011     let loclist = g:SyntasticLoclist.current()
                            
    1              0.000008     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
    1   0.000037   0.000012     let do_jump = syntastic#util#var('auto_jump') + 0
    1              0.000004     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
    1              0.000006     let w:syntastic_loclist_set = 0
    1   0.000033   0.000009     if syntastic#util#var('always_populate_loc_list') || do_jump
    1   0.000036   0.000012         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist (new)')
    1   0.000043   0.000038         call setloclist(0, loclist.getRaw())
    1              0.000015         let w:syntastic_loclist_set = 1
    1              0.000007         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
    1              0.000002     endif
                                " }}}3
                            
    1   0.001757   0.000015     call s:notifiers.refresh(loclist)

FUNCTION  67()
Called 1 time
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
    1              0.000010     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    1              0.000007         let self._mode = 'active'
    1              0.000070         let self._activeFiletypes = []
    1              0.000016         let self._passiveFiletypes = []
    1              0.000004     endif

FUNCTION  68()
Called 1 time
Total time:   0.000093
 Self time:   0.000052

count  total (s)   self (s)
    1              0.000014     let fts = split(a:filetype, '\m\.')
                            
    1   0.000019   0.000013     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    1   0.000047   0.000013         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  69()
Called 1 time
Total time:   0.000136
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000010     let local_mode = get(b:, 'syntastic_mode', '')
    1              0.000008     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
    1   0.000108   0.000015     return self.allowsAutoChecking(&filetype)

FUNCTION  366()
Called 25 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
   25              0.000428   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>9_isNode()
Called 1 time
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
    1              0.000010 	let shebang = getline(1)
    1              0.000078 	if shebang =~# '^#!.*/bin/env\s\+node\>' | return 1 | en
    1              0.000025 	if shebang =~# '^#!.*/bin/node\>' | return 1 | en
    1              0.000003 	return 0

FUNCTION  70()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006     return self._mode ==# 'passive'

FUNCTION  75()
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000033     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  77()
Called 2 times
Total time:   0.003533
 Self time:   0.001355

count  total (s)   self (s)
    2   0.000042   0.000027     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    2   0.000063   0.000024     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
   12              0.000048     for type in self._enabled_types
   10              0.000228         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   10   0.000456   0.000199         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
    8              0.000070             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    2              0.000023                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
    2   0.000279   0.000043                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    2   0.000647   0.000031                     call self._notifier[type].refresh(a:loclist)
    2   0.000139   0.000038                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    2              0.000005                 endif
    2              0.000004             else
    6   0.000987   0.000073                 call self._notifier[type].refresh(a:loclist)
    6              0.000012             endif
    8              0.000014         endif
   10              0.000026     endfor

FUNCTION  78()
Called 1 time
Total time:   0.000631
 Self time:   0.000431

count  total (s)   self (s)
    1   0.000041   0.000013     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
    6              0.000021     for type in self._enabled_types
    5              0.000105         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
    5              0.000057         if has_key(g:{class}, 'reset')
    3   0.000219   0.000048             call self._notifier[type].reset(a:loclist)
    3              0.000006         endif
                            
                                    " also reset stamps
    5              0.000041         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    2              0.000023             let b:syntastic_private_{type}_stamp = []
    2              0.000004         endif
    5              0.000013     endfor

FUNCTION  165()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000008     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
    1              0.000003     return s:keyMaps

FUNCTION  166()
Called 1 time
Total time:   0.000150
 Self time:   0.000132

count  total (s)   self (s)
    8   0.000049   0.000030     for i in s:KeyMap.All()
    8              0.000048          if i.key ==# a:key && i.scope ==# a:scope
    1              0.000003             return i
                                    endif
    7              0.000016     endfor
                                return {}

FUNCTION  airline#highlighter#add_separator()
Called 21 times
Total time:   0.016693
 Self time:   0.000792

count  total (s)   self (s)
   21              0.000339   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   21   0.016323   0.000421   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  xolox#misc#path#absolute()
Called 1 time
Total time:   0.000427
 Self time:   0.000230

count  total (s)   self (s)
                              " Canonicalize and resolve a pathname, *regardless of whether it exists*.
                              " This is intended to support string comparison to determine whether two
                              " pathnames point to the same directory or file.
    1              0.000011   if type(a:path) == type('')
    1              0.000007     let path = a:path
                                " Make the pathname absolute.
    1              0.000019     if path =~ '^\~'
                                  " Expand ~ to $HOME.
    1              0.000014       let path = $HOME . '/' . path[1:]
    1              0.000006     elseif xolox#misc#path#is_relative(path)
                                  " Make relative pathnames absolute.
                                  let path = getcwd() . '/' . path
                                endif
                                " Resolve symbolic links to find the canonical pathname. In my tests this
                                " also removes all symbolic pathname segments (`.' and `..'), even when
                                " the pathname does not exist. Also there used to be a bug in resolve()
                                " where it wouldn't resolve pathnames ending in a directory separator.
                                " Since it's not much trouble to work around, that's what we do.
    1              0.000054     let path = resolve(substitute(path, s:windows_compatible ? '[\/]\+$' : '/\+$', '', ''))
                                " Normalize directory separators (especially relevant on Windows).
    1   0.000170   0.000030     let parts = xolox#misc#path#split(path)
    1              0.000006     if s:windows_compatible && parts[0] =~ '^[\/][\/]'
                                  " Also normalize the two leading "directory separators" (I'm not
                                  " sure what else to call them :-) in Windows UNC pathnames.
                                  let parts[0] = repeat(xolox#misc#path#directory_separator(), 2) . parts[0][2:]
                                elseif s:windows_compatible && parts[0] =~ '^[\/]$'
                                  " If a pathname is relative to the current drive we should add
                                  " the drive letter in order to make the pathname absolute.
                                  let parts[0] = matchstr(getcwd(), '^\a:')
                                endif
    1   0.000083   0.000026     return xolox#misc#path#join(parts)
                              endif
                              return ''

FUNCTION  airline#highlighter#get_highlight()
Called 102 times
Total time:   0.027096
 Self time:   0.007848

count  total (s)   self (s)
  102   0.009263   0.001210   let fg = s:get_syn(a:group, 'fg')
  102   0.008959   0.001215   let bg = s:get_syn(a:group, 'bg')
  102              0.003289   let reverse = has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  102   0.005327   0.001875   return reverse ? s:get_array(bg, fg, a:000) : s:get_array(fg, bg, a:000)

FUNCTION  xolox#session#locking_enabled()
Called 1 time
Total time:   0.000073
 Self time:   0.000022

count  total (s)   self (s)
                              " Check whether session locking is enabled. Returns true (1) when locking is
                              " enabled, false (0) otherwise.
                              "
                              " By default session locking is enabled but users can opt-out by setting
                              " `g:session_lock_enabled` to false (0).
    1   0.000065   0.000015   return xolox#misc#option#get('session_lock_enabled', 1)

FUNCTION  airline#util#wrap()
Called 19 times
Total time:   0.000380
 Self time:   0.000380

count  total (s)   self (s)
   19              0.000143   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   19              0.000112   return a:text

FUNCTION  <SNR>102_InitColor()
Called 2 times
Total time:   0.000357
 Self time:   0.000357

count  total (s)   self (s)
    2              0.000010     if ! g:indentLine_setColors
                                    return
                                endif
                            
    2              0.000015     if ! exists("g:indentLine_color_term")
    2              0.000011         if &background ==# "light"
    2              0.000011             let term_color = 249
    2              0.000004         else
                                        let term_color = 239
                                    endif
    2              0.000003     else
                                    let term_color = g:indentLine_color_term
                                endif
                            
    2              0.000014     if ! exists("g:indentLine_color_gui")
    2              0.000007         if &background ==# "light"
    2              0.000010             let gui_color = "Grey70"
    2              0.000004         else
                                        let gui_color = "Grey30"
                                    endif
    2              0.000003     else
                                    let gui_color = g:indentLine_color_gui
                                endif
                            
    2              0.000067     execute "highlight Conceal ctermfg=" . term_color . " ctermbg=NONE"
    2              0.000058     execute "highlight Conceal guifg=" . gui_color .  " guibg=NONE"
                            
    2              0.000008     if &term ==# "linux"
                                    if &background ==# "light"
                                        let tty_color = exists("g:indentLine_color_tty_light") ? g:indentLine_color_tty_light : 4
                                    else
                                        let tty_color = exists("g:indentLine_color_tty_dark") ? g:indentLine_color_tty_dark : 2
                                    endif
                                    execute "highlight Conceal cterm=bold ctermfg=" . tty_color .  " ctermbg=NONE"
                                endif

FUNCTION  <SNR>123_add_section()
Called 21 times
Total time:   0.002606
 Self time:   0.000980

count  total (s)   self (s)
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   21              0.000089     if a:key == 'warning'
    3   0.000074   0.000031       call a:builder.add_raw('%(')
    3              0.000006     endif
   21   0.001963   0.000418     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   21              0.000088     if a:key == 'warning'
    3   0.000062   0.000023       call a:builder.add_raw('%)')
    3              0.000006     endif

FUNCTION  170()
Called 1 time
Total time:   0.296416
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000016     let Callback = function(self.callback)
    1              0.000003     if a:0
    1   0.296385   0.000027         call Callback(a:1)
    1              0.000002     else
                                    call Callback()
                                endif

FUNCTION  171()
Called 1 time
Total time:   0.306456
 Self time:   0.000218

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    1   0.000039   0.000021     if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
    1   0.009768   0.000114     let node = g:NERDTreeFileNode.GetSelected()
    1              0.000006     if !empty(node)
                            
                                    "try file node
    1              0.000005         if !node.path.isDirectory
    1   0.000172   0.000022             let km = s:KeyMap.FindFor(a:key, "FileNode")
    1              0.000005             if !empty(km)
    1   0.296433   0.000018                 return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
                                    if node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "DirNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, "Node")
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, "all")
                                if !empty(km)
                                    return km.invoke()
                                endif

FUNCTION  <SNR>55_ClearMatches()
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000007   if !exists('w:colormatches')
                                return
                              endif
    1              0.000008   for i in values(w:colormatches)
                                try
                                  call matchdelete(i)
                                catch /.*/
                                  " matches have been cleared in other ways, e.g. user has called clearmatches()
                                endtry
                              endfor
    1              0.000004   unlet w:colormatches

FUNCTION  syntastic#log#debugShowVariables()
Called 2 times
Total time:   0.000133
 Self time:   0.000088

count  total (s)   self (s)
    2   0.000123   0.000078     if !s:_isDebugEnabled(a:level)
    2              0.000005         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  airline#extensions#tabline#get()
Called 2 times
Total time:   0.011333
 Self time:   0.000354

count  total (s)   self (s)
    2              0.000035   let curtabcnt = tabpagenr('$')
    2              0.000015   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                              endif
                            
    2              0.000020   if s:show_buffers && curtabcnt == 1 || !s:show_tabs
    2   0.011205   0.000226     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  93()
Called 4 times
Total time:   0.000159
 Self time:   0.000062

count  total (s)   self (s)
    4   0.000155   0.000058     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  94()
Called 2 times
Total time:   0.000617
 Self time:   0.000120

count  total (s)   self (s)
    2   0.000065   0.000025     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
    2   0.000075   0.000029     let old_signs = copy(self._bufSignIds())
    2   0.000087   0.000013     if self.enabled()
    2   0.000265   0.000021         call self._signErrors(a:loclist)
    2              0.000004     endif
    2   0.000114   0.000020     call self._removeSigns(old_signs)

FUNCTION  96()
Called 2 times
Total time:   0.000243
 Self time:   0.000232

count  total (s)   self (s)
    2              0.000011     let loclist = a:loclist
    2   0.000025   0.000013     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  97()
Called 2 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    2              0.000015     if has('signs')
    2              0.000041         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    2              0.000004     endif

FUNCTION  98()
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000018     if !exists('b:syntastic_private_sign_ids')
    1              0.000007         let b:syntastic_private_sign_ids = []
    1              0.000002     endif
    2              0.000009     return b:syntastic_private_sign_ids

FUNCTION  99()
Called 1 time
Total time:   0.000105
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000005     let prependCWD = 0
    1   0.000051   0.000026     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
    1              0.000013         let prependCWD = a:str !~# '^/'
    1              0.000002     endif
                            
    1              0.000005     let toReturn = a:str
    1              0.000003     if prependCWD
                                    let toReturn = getcwd() . s:Path.Slash() . a:str
                                endif
                            
    1              0.000003     return toReturn

FUNCTION  airline#util#getwinvar()
Called 24 times
Total time:   0.000239
 Self time:   0.000239

count  total (s)   self (s)
   24              0.000216     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>56_CreateGrepDictionary()
Called 1 time
Total time:   0.000147
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000007     if exists("s:Dict")
    1   0.000135   0.000032         call s:CheckDefaultUserPattern()
    1              0.000002         return
                                endif
                            
                                let s:Dict = [ ]
                                call add(s:Dict, [ "All" , "*", g:EasyGrepMode==s:EasyGrepModeAll ? 1 : 0 ] )
                                call add(s:Dict, [ "Buffers" , "*Buffers*", g:EasyGrepMode==s:EasyGrepModeBuffers ? 1 : 0  ] )
                                call add(s:Dict, [ "TrackExt" , "*", g:EasyGrepMode==s:EasyGrepModeTracked ? 1 : 0  ] )
                                call add(s:Dict, [ "User" , "", g:EasyGrepMode==s:EasyGrepModeUser ? 1 : 0  ] )
                            
                                if len(s:Dict) != s:EasyGrepNumModes
                                    call EasyGrep#InternalFailure("EasyGrep's default settings are not internally consistent; please reinstall")
                                endif
                            
                                call s:ParseFileAssociationList()
                                let s:NumFileAssociations = len(s:Dict) - s:EasyGrepNumModes
                            

FUNCTION  <SNR>122_should_change_group()
Called 17 times
Total time:   0.010024
 Self time:   0.001049

count  total (s)   self (s)
   17              0.000108   if a:group1 == a:group2
                                return 0
                              endif
   17   0.004952   0.000229   let color1 = airline#highlighter#get_highlight(a:group1)
   17   0.004462   0.000210   let color2 = airline#highlighter#get_highlight(a:group2)
   17              0.000179   if has('gui_running') || (has("termtruecolor") && &guicolors == 1)
   17              0.000179     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  airline#extensions#whitespace#check()
Called 2 times
Total time:   0.003377
 Self time:   0.001506

count  total (s)   self (s)
    2              0.000028   if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines
                                return ''
                              endif
                            
    2              0.000018   if !exists('b:airline_whitespace_check')
    1              0.000007     let b:airline_whitespace_check = ''
    1              0.000013     let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
    1              0.000004     let trailing = 0
    1              0.000009     if index(checks, 'trailing') > -1
    1              0.001155       let trailing = search('\s$', 'nw')
    1              0.000002     endif
                            
    1              0.000004     let mixed = 0
    1              0.000007     if index(checks, 'indent') > -1
    1   0.001903   0.000032       let mixed = s:check_mixed_indent()
    1              0.000003     endif
                            
    1              0.000004     let long = 0
    1              0.000008     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    1              0.000007     if trailing != 0 || mixed != 0 || long != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixed)
                                    endif
                                    if long != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:long_format, long)
                                    endif
                                  endif
                                endif
    1              0.000002   endif
    2              0.000010   return b:airline_whitespace_check

FUNCTION  syntastic#util#setWids()
Called 1 time
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
    2              0.000060     for tab in range(1, tabpagenr('$'))
    2              0.000020         for win in range(1, tabpagewinnr(tab, '$'))
    1              0.000011             if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
    1              0.000026                 call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
    1              0.000008                 let s:_wid_pool += 1
    1              0.000003             endif
    1              0.000009         endfor
    1              0.000002     endfor

FUNCTION  signature#mark#GetList()
Called 2 times
Total time:   0.006483
 Self time:   0.006483

count  total (s)   self (s)
                              " Description: Takes two optional arguments - mode/line no. and scope
                              "              If no arguments are specified, returns a list of [mark, line no.] pairs that are in use in the buffer
                              "              or are free to be placed in which case, line no. is 0
                              "
                              "   Arguments: mode   = 'used'     : Returns list of [ [used marks, line no., buf no.] ]
                              "                       'free'     : Returns list of [ free marks ]
                              "              scope  = 'buf_curr' : Limits scope to current buffer i.e used/free marks in current buffer
                              "                       'buf_all'  : Set scope to all buffers i.e used/free marks from all buffers
                              "              [type] = 'global'   : Return only global marks
                              "
                              "        NOTE: If type is specified as 'global', it will override and set scope to 'buf_all'.
                            
    2              0.000012   let l:marks_list = []
    2              0.000016   let l:line_tot = line('$')
    2              0.000015   let l:buf_curr = bufnr('%')
    2              0.000014   let l:type     = (a:0 ? a:1 : "")
                            
                              " Add local marks first
    2              0.000012   if (l:type !=? "global")
   54              0.001295     for i in filter(split(b:SignatureIncludeMarks, '\zs'), 'v:val =~# "[a-z]"')
   52              0.000842       let l:marks_list = add(l:marks_list, [i, line("'" .i), l:buf_curr])
   52              0.000103     endfor
    2              0.000005   endif
                              " Add global (uppercase) marks to list
   54              0.001246   for i in filter( split( b:SignatureIncludeMarks, '\zs' ), 'v:val =~# "[A-Z]"' )
   52              0.000561     let [ l:buf, l:line, l:col, l:off ] = getpos( "'" . i )
   52              0.000698     let l:marks_list = add(l:marks_list, [i, l:line, l:buf])
   52              0.000100   endfor
                            
    2              0.000013   if (a:mode ==? 'used')
    1              0.000005     if (a:scope ==? 'buf_curr')
    1              0.000521       call filter( l:marks_list, '(v:val[2] == l:buf_curr) && (v:val[1] > 0)' )
    1              0.000003     else
                                  call filter( l:marks_list, 'v:val[1] > 0' )
                                endif
    1              0.000002   else
    1              0.000006     if (a:scope ==? 'buf_all')
                                  call filter( l:marks_list, 'v:val[1] == 0' )
                                else
    1              0.000432       call filter( l:marks_list, '(v:val[1] == 0) || (v:val[2] != l:buf_curr)' )
    1              0.000002     endif
    1              0.000331     call map( l:marks_list, 'v:val[0]' )
    1              0.000002   endif
                            
    2              0.000008   return l:marks_list

FUNCTION  <SNR>39__resolve_filetypes()
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000013     let type = len(a:filetypes) ? a:filetypes[0] : &filetype
    1              0.000017     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )

FUNCTION  <SNR>39__ignore_file()
Called 2 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
    2              0.000129     let fname = fnamemodify(a:filename, ':p')
    2              0.000015     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    2              0.000005     return 0

FUNCTION  syntastic#util#var()
Called 18 times
Total time:   0.000437
 Self time:   0.000437

count  total (s)   self (s)
   18              0.000416     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''

FUNCTION  syntastic#util#compareLexi()
Called 2 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    3              0.000041     for idx in range(max([len(a:a), len(a:b)]))
    3              0.000033         let a_element = str2nr(get(a:a, idx, 0))
    3              0.000029         let b_element = str2nr(get(a:b, idx, 0))
    3              0.000013         if a_element != b_element
    2              0.000011             return a_element > b_element ? 1 : -1
                                    endif
    1              0.000003     endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  ctrlp#utils#mkdir()
Called 2 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    2              0.000071 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    2              0.000006 	retu a:dir

FUNCTION  nerdtree#runningWindows()
Called 85 times
Total time:   0.001604
 Self time:   0.001604

count  total (s)   self (s)
   85              0.001536     return has("win16") || has("win32") || has("win64")

FUNCTION  <SNR>55_RgbColor()
Called 87 times
Total time:   0.010961
 Self time:   0.010961

count  total (s)   self (s)
   87              0.000293   let ret = []
   87              0.000286   let place = 0
   87              0.000565   let colorpat = '\<rgb(\v\s*(\d+(\%)?)\s*,\s*(\d+%(\2))\s*,\s*(\d+%(\2))\s*\)'
   87              0.000208   while 1
   87              0.002429     let foundcolor = matchlist(a:str, colorpat, place)
   87              0.000411     if empty(foundcolor)
   87              0.000194       break
                                endif
                                let place = matchend(a:str, colorpat, place)
                                if foundcolor[2] == '%'
                                  let r = foundcolor[1] * 255 / 100
                                  let g = foundcolor[3] * 255 / 100
                                  let b = foundcolor[4] * 255 / 100
                                else
                                  let r = foundcolor[1]
                                  let g = foundcolor[3]
                                  let b = foundcolor[4]
                                endif
                                if r > 255 || g > 255 || b > 255
                                  break
                                endif
                                let pat = printf('\<rgb(\v\s*%s\s*,\s*%s\s*,\s*%s\s*\)', foundcolor[1], foundcolor[3], foundcolor[4])
                                if foundcolor[2] == '%'
                                  let pat = substitute(pat, '%', '\\%', 'g')
                                endif
                                let l:color = printf('#%02x%02x%02x', r, g, b)
                                call add(ret, [l:color, pat])
                              endwhile
   87              0.000225   return ret

FUNCTION  <SNR>122_get_accented_line()
Called 25 times
Total time:   0.003772
 Self time:   0.003772

count  total (s)   self (s)
   25              0.000136   if a:self._context.active
   25              0.000120     let contents = []
   25              0.000555     let content_parts = split(a:contents, '__accent')
   48              0.000235     for cpart in content_parts
   23              0.000506       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   23              0.000399       call add(contents, cpart)
   23              0.000083     endfor
   25              0.000287     let line = join(contents, a:group)
   25              0.000484     let line = substitute(line, '__restore__', a:group, 'g')
   25              0.000057   else
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
   25              0.000081   return line

FUNCTION  airline#highlighter#highlight()
Called 2 times
Total time:   0.024873
 Self time:   0.008270

count  total (s)   self (s)
    2              0.000088   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    2              0.000145   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    2              0.000017   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    7              0.000033   for mode in mapped
    5              0.000086     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    2              0.000022       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   24              0.000111       for kvp in items(dict)
   22              0.000135         let mode_colors = kvp[1]
   22   0.002508   0.000438         call airline#highlighter#exec(kvp[0].suffix, mode_colors)
                            
   66              0.000308         for accent in keys(s:accents)
   44              0.000295           if !has_key(p.accents, accent)
                                        continue
                                      endif
   44              0.000370           let colors = copy(mode_colors)
   44              0.000287           if p.accents[accent][0] != ''
   22              0.000178             let colors[0] = p.accents[accent][0]
   22              0.000039           endif
   44              0.000247           if p.accents[accent][2] != ''
   22              0.000158             let colors[2] = p.accents[accent][2]
   22              0.000037           endif
   44              0.000200           if len(colors) >= 5
   24              0.000218             let colors[4] = get(p.accents[accent], 4, '')
   24              0.000044           else
   20              0.000371             call add(colors, get(p.accents[accent], 4, ''))
   20              0.000038           endif
   44   0.004939   0.000660           call airline#highlighter#exec(kvp[0].suffix.'_'.accent, colors)
   44              0.000111         endfor
   22              0.000049       endfor
                            
                                  " TODO: optimize this
   15              0.000077       for sep in items(s:separators)
   13   0.010614   0.000359         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   13              0.000059       endfor
    2              0.000004     endif
    5              0.000010   endfor

FUNCTION  signature#utils#Set()
Called 7 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
    7              0.000047   if !exists(a:var)
    7              0.000033     if type(a:default)
    3              0.000055       execute 'let' a:var '=' string(a:default)
    3              0.000006     else
    4              0.000052       execute 'let' a:var '=' a:default
    4              0.000008     endif
    7              0.000012   endif
    7              0.000021   return a:var

FUNCTION  airline#extensions#ctrlp#apply()
Called 3 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    3              0.000064   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  xolox#session#get_names()
Called 1 time
Total time:   0.003000
 Self time:   0.001405

count  total (s)   self (s)
                              " Get the names of all available sessions. This scans the directory
                              " configured with `g:session_directory` for files that end with the suffix
                              " configured with `g:session_extension`, takes the base name of each file
                              " and decodes any URL encoded characters. Returns a list of strings.
                              "
                              " If the first argument is true (1) then the user defined function
                              " configured with `g:session_name_suggestion_function` is called to find
                              " suggested session names, which are prefixed to the list of available
                              " sessions, otherwise the argument should be false (0).
    1   0.002054   0.000825   let directory = xolox#misc#path#absolute(g:session_directory)
    1   0.000466   0.000390   let filenames = split(glob(xolox#misc#path#merge(directory, '*' . g:session_extension)), "\n")
    1   0.000439   0.000149   call map(filenames, 'xolox#session#path_to_name(v:val)')
    1              0.000009   if a:include_suggestions && !empty(g:session_name_suggestion_function)
                                let suggested_names = call(g:session_name_suggestion_function, [])
                                let filenames = suggested_names + filenames
                              endif
    1              0.000003   return filenames

FUNCTION  <SNR>55_PreviewColorInLine()
Called 87 times
Total time:   0.049535
 Self time:   0.009838

count  total (s)   self (s)
   87              0.000636   let line = getline(a:where)
  348              0.001181   for Func in s:ColorFinder
  261   0.042343   0.002645     let ret = Func(line, a:where)
                                " returned a list of a list: color as #rrggbb, text pattern to highlight
  261              0.000736     for r in ret
                                  call s:SetMatcher(r[0], r[1])
                                endfor
  261              0.000553   endfor

FUNCTION  ctrlp#utils#opts()
Called 1 time
Total time:   0.000245
 Self time:   0.000176

count  total (s)   self (s)
    1   0.000045   0.000027 	let s:lash = ctrlp#utils#lash()
    1   0.000056   0.000028 	let usrhome = $HOME . s:lash( $HOME )
    1              0.000015 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
    1   0.000085   0.000063 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
    1              0.000008 	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
    1              0.000006 	let s:cache_dir = cadir

FUNCTION  ctrlp#utils#lash()
Called 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000040 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  xolox#misc#os#is_win()
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
                              " Returns 1 (true) when on Microsoft Windows, 0 (false) otherwise.
    1              0.000027   return has('win16') || has('win32') || has('win64')

FUNCTION  airline#parts#paste()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000019   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
Called 3 times
Total time:   0.038729
 Self time:   0.000782

count  total (s)   self (s)
    3   0.000093   0.000058   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    3              0.000094   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor
                            
    3              0.000017   unlet! w:airline_render_left
    3              0.000012   unlet! w:airline_render_right
   27              0.000081   for section in s:sections
   24              0.000144     unlet! w:airline_section_{section}
   24              0.000045   endfor
                            
    3              0.000016   let w:airline_active = 1
    3              0.000048   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    3   0.038008   0.000095   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  xolox#misc#path#split()
Called 1 time
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
                              " Split a pathname (the first and only argument) into a list of pathname
                              " components.
                              "
                              " On Windows, pathnames starting with two slashes or backslashes are UNC
                              " paths where the leading slashes are significant... In this case we split
                              " like this:
                              "
                              " - Input: `'//server/share/directory'`
                              " - Result: `['//server', 'share', 'directory']`
                              "
                              " Everything except Windows is treated like UNIX until someone has a better
                              " suggestion :-). In this case we split like this:
                              "
                              " - Input: `'/foo/bar/baz'`
                              " - Result: `['/', 'foo', 'bar', 'baz']`
                              "
                              " To join a list of pathname components back into a single pathname string,
                              " use the `xolox#misc#path#join()` function.
    1              0.000008   if type(a:path) == type('')
    1              0.000004     if s:windows_compatible
                                  if a:path =~ '^[\/][\/]'
                                    " UNC pathname.
                                    return split(a:path, '\%>2c[\/]\+')
                                  else
                                    " If it's not a UNC pathname we can simply split on slashes and
                                    " backslashes, although we should preserve a leading slash (which
                                    " denotes a pathname that is 'absolute to the current drive').
                                    let absolute = (a:path =~ '^[\/]')
                                    let segments = split(a:path, '[\/]\+')
                                    return absolute ? insert(segments, a:path[0]) : segments
                                  endif
                                else
                                  " Everything else is treated as UNIX.
    1              0.000013       let absolute = (a:path =~ '^/')
    1              0.000027       let segments = split(a:path, '/\+')
    1              0.000026       return absolute ? insert(segments, '/') : segments
                                endif
                              endif
                              return []

FUNCTION  <SNR>39_CacheErrors()
Called 1 time
Total time:   0.002362
 Self time:   0.000560

count  total (s)   self (s)
    1   0.000052   0.000027     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    1   0.001026   0.000021     call s:ClearCache()
    1   0.000112   0.000013     let newLoclist = g:SyntasticLoclist.New([])
                            
    1   0.000263   0.000010     if !s:_skip_file()
                                    " debug logging {{{3
    1   0.000039   0.000015         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    1   0.000049   0.000029         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    1   0.000065   0.000047         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    1   0.000063   0.000031         let filetypes = s:_resolve_filetypes([])
    1   0.000060   0.000032         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
    1              0.000008         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    1              0.000009         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    1              0.000004         let clist = []
    1              0.000005         for type in filetypes
                                        call extend(clist, s:registry.getCheckers(type, a:checker_names))
                                    endfor
                            
    1              0.000003         let names = []
    1              0.000005         let unavailable_checkers = 0
    1              0.000004         for checker in clist
                                        let cname = checker.getFiletype() . '/' . checker.getName()
                                        if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            let newLoclist = newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
    1              0.000006         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    1              0.000007         if len(clist) == unavailable_checkers
    1              0.000006             if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
    1   0.000038   0.000017                 call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
    1              0.000002             endif
    1              0.000002         endif
                                    " }}}3
                            
    1   0.000032   0.000014         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    1              0.000004         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
    1              0.000002     endif
                            
    1   0.000274   0.000013     call newLoclist.deploy()

FUNCTION  <SNR>56_IsLink()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000012     return a:str[0] == '<' && a:str[len(a:str)-1] == '>'

FUNCTION  SyntasticLoclistHide()
Called 1 time
Total time:   0.000054
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000046   0.000019     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
    1              0.000005     silent! lclose

FUNCTION  <SNR>111_check_mixed_indent()
Called 1 time
Total time:   0.001871
 Self time:   0.001871

count  total (s)   self (s)
    1              0.000005   if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif s:indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    1              0.001832     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  airline#parts#readonly()
Called 13 times
Total time:   0.000122
 Self time:   0.000122

count  total (s)   self (s)
   13              0.000098   return &readonly ? g:airline_symbols.readonly : ''

FUNCTION  <SNR>52_addtomrufs()
Called 3 times
Total time:   0.009681
 Self time:   0.001060

count  total (s)   self (s)
    3              0.000221 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    3              0.000052 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    3              0.000048 	let abs_fn = fnamemodify(fn,':p')
    3              0.000443 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn) | retu
                            	en
    2              0.000033 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    2              0.000006 	if idx
    1              0.000026 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    1              0.000011 		cal insert(s:mrufs, fn)
    1              0.000009 		if {s:soup} && idx < 0
    1   0.008771   0.000150 			cal s:savetofile(s:mergelists())
    1              0.000002 		en
    1              0.000002 	en

FUNCTION  nerdtree#has_opt()
Called 31 times
Total time:   0.000275
 Self time:   0.000275

count  total (s)   self (s)
   31              0.000249     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  airline#highlighter#exec()
Called 102 times
Total time:   0.010241
 Self time:   0.010241

count  total (s)   self (s)
  102              0.000503   let colors = a:colors
  102              0.000368   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  102              0.006993   exec printf('hi %s %s %s %s %s %s %s %s', a:group, get(colors, 0, '') != '' ? 'guifg='.colors[0] : '', get(colors, 1, '') != '' ? 'guibg='.colors[1] : '', get(colors, 2, '') != '' ? 'ctermfg='.colors[2] : '', get(colors, 3, '') != '' ? 'ctermbg='.colors[3] : '', get(colors, 4, '') != '' ? 'gui='.colors[4] : '', get(colors, 4, '') != '' ? 'cterm='.colors[4] : '', get(colors, 4, '') != '' ? 'term='.colors[4] : '')

FUNCTION  airline#extensions#tabline#formatters#default#format()
Called 2 times
Total time:   0.000481
 Self time:   0.000354

count  total (s)   self (s)
    2              0.000013   let _ = ''
                            
    2              0.000023   let name = bufname(a:bufnr)
    2              0.000016   if empty(name)
                                let _ .= '[No Name]'
                              else
    2              0.000011     if s:fnamecollapse
    2              0.000124       let _ .= substitute(fnamemodify(name, s:fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
    2              0.000005     else
                                  let _ .= fnamemodify(name, s:fmod)
                                endif
    2              0.000025     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
                                endif
    2              0.000004   endif
                            
    2   0.000195   0.000068   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 2 times
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    2              0.000025   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
    2              0.000040   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
    2              0.000030   if getbufvar(a:bufnr, '&modified') == 1
                                let _ .= s:buf_modified_symbol
                              endif
    2              0.000008   return _

FUNCTION  <SNR>7_DetectJS()
Called 1 time
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000039     if getline(1) =~# '^#!.*/bin/env\s\+node\>'
                                    setfiletype javascript
                                endif

FUNCTION  <SNR>55_RgbaColor()
Called 87 times
Total time:   0.022232
 Self time:   0.022232

count  total (s)   self (s)
   87              0.000785   if has("gui_running")
   87              0.001183     let bg = synIDattr(synIDtrans(hlID("Normal")), "bg")
   87              0.000871     let bg_r = str2nr(bg[1].bg[2], 16)
   87              0.000758     let bg_g = str2nr(bg[3].bg[4], 16)
   87              0.000736     let bg_b = str2nr(bg[5].bg[6], 16)
   87              0.000185   else
                                " translucent colors would display incorrectly, so ignore the alpha value
                                return s:RgbaColorForTerm(a:str, a:lineno)
                              endif
   87              0.000289   let ret = []
   87              0.000283   let place = 0
   87              0.000676   let colorpat = '\<rgba(\v\s*(\d+(\%)?)\s*,\s*(\d+%(\2))\s*,\s*(\d+%(\2))\s*,\s*(-?[.[:digit:]]+)\s*\)'
   87              0.000218   while 1
   87              0.002808     let foundcolor = matchlist(a:str, colorpat, place)
   87              0.000416     if empty(foundcolor)
   87              0.000195       break
                                endif
                                let place = matchend(a:str, colorpat, place)
                                if foundcolor[2] == '%'
                                  let ar = foundcolor[1] * 255 / 100
                                  let ag = foundcolor[3] * 255 / 100
                                  let ab = foundcolor[4] * 255 / 100
                                else
                                  let ar = foundcolor[1]
                                  let ag = foundcolor[3]
                                  let ab = foundcolor[4]
                                endif
                                if ar > 255 || ag > 255 || ab > 255
                                  break
                                endif
                                let alpha = str2float(foundcolor[5])
                                if alpha < 0
                                  let alpha = 0.0
                                elseif alpha > 1
                                  let alpha = 1.0
                                endif
                                let pat = printf('\<rgba(\v\s*%s\s*,\s*%s\s*,\s*%s\s*,\s*%s0*\s*\)', foundcolor[1], foundcolor[3], foundcolor[4], foundcolor[5])
                                if foundcolor[2] == '%'
                                  let pat = substitute(pat, '%', '\\%', 'g')
                                endif
                                let r = float2nr(ceil(ar * alpha) + ceil(bg_r * (1 - alpha)))
                                let g = float2nr(ceil(ag * alpha) + ceil(bg_g * (1 - alpha)))
                                let b = float2nr(ceil(ab * alpha) + ceil(bg_b * (1 - alpha)))
                                if r > 255
                                  let r = 255
                                endif
                                if g > 255
                                  let g = 255
                                endif
                                if b > 255
                                  let b = 255
                                endif
                                let l:color = printf('#%02x%02x%02x', r, g, b)
                                call add(ret, [l:color, pat])
                              endwhile
   87              0.000231   return ret

FUNCTION  336()
Called 1 time
Total time:   0.000076
 Self time:   0.000072

count  total (s)   self (s)
                                "have to do this work around because match() returns bytes, not chars
    1              0.000034     let numLeadBytes = match(a:line, '\M\[^ '.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.']')
    1              0.000015     let leadChars = strchars(a:line[0:numLeadBytes-1])
                            
    1   0.000021   0.000018     return leadChars / s:UI.IndentWid()

FUNCTION  199()
Called 1 time
Total time:   0.296333
 Self time:   0.000027

count  total (s)   self (s)
    1   0.296331   0.000026     call self.open(a:0 ? a:1 : {})

FUNCTION  207()
Called 8 times
Total time:   0.003852
 Self time:   0.000125

count  total (s)   self (s)
    8   0.003791   0.000065     if a:path.equals(self.path)
    1              0.000003         return self
                                endif
    7              0.000016     return {}

FUNCTION  <SNR>21_invoke_funcrefs()
Called 3 times
Total time:   0.037913
 Self time:   0.000345

count  total (s)   self (s)
    3   0.000264   0.000051   let builder = airline#builder#new(a:context)
    3   0.005776   0.000092   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    3              0.000011   if err == 1
    3   0.031723   0.000053     let a:context.line = builder.build()
    3              0.000039     let s:contexts[a:context.winnr] = a:context
    3              0.000078     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
    3              0.000007   endif

FUNCTION  airline#parts#crypt()
Called 2 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000041   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  212()
Called 1 time
Total time:   0.009654
 Self time:   0.000114

count  total (s)   self (s)
    1              0.000010     try
    1   0.003465   0.000038         let path = b:NERDTree.ui.getPath(line("."))
    1              0.000006         if path ==# {}
                                        return {}
                                    endif
    1   0.006148   0.000034         return b:NERDTree.root.findNode(path)
                                catch /^NERDTree/
                                    return {}
                                endtry

FUNCTION  216()
Called 1 time
Total time:   0.296305
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000005     let opts = a:0 ? a:1 : {}
    1   0.000168   0.000019     let opener = g:NERDTreeOpener.New(self.path, opts)
    1   0.296129   0.000016     call opener.open(self)

FUNCTION  <SNR>52_savetofile()
Called 2 times
Total time:   0.010096
 Self time:   0.000055

count  total (s)   self (s)
    2   0.010093   0.000052 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  syntastic#log#debugDump()
Called 1 time
Total time:   0.000051
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000048   0.000012     if !s:_isDebugEnabled(a:level)
    1              0.000002         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  <SNR>55_HexCode()
Called 87 times
Total time:   0.006504
 Self time:   0.006504

count  total (s)   self (s)
   87              0.000301   let ret = []
   87              0.000288   let place = 0
   87              0.000494   let colorpat = '#[0-9A-Fa-f]\{3\}\>\|#[0-9A-Fa-f]\{6\}\>'
   87              0.000206   while 1
   87              0.001629     let foundcolor = matchstr(a:str, colorpat, place)
   87              0.000315     if foundcolor == ''
   87              0.000191       break
                                endif
                                let place = matchend(a:str, colorpat, place)
                                let pat = foundcolor . '\>'
                                if len(foundcolor) == 4
                                  let foundcolor = substitute(foundcolor, '[[:xdigit:]]', '&&', 'g')
                                endif
                                call add(ret, [foundcolor, pat])
                              endwhile
   87              0.000228   return ret

FUNCTION  airline#parts#mode()
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000016   return get(w:, 'airline_current_mode', '')

FUNCTION  airline#extensions#tabline#buflist#invalidate()
Called 4 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    4              0.000022   unlet! s:current_buffer_list

FUNCTION  airline#extensions#quickfix#apply()
Called 3 times
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
    3              0.000021   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  colorizer#ColorHighlight()
Called 1 time
Total time:   0.051185
 Self time:   0.001605

count  total (s)   self (s)
    1              0.000008   if exists('w:colormatches')
    1              0.000004     if !a:update
                                  return
                                endif
    1   0.000069   0.000024     call s:ClearMatches()
    1              0.000002   endif
    1              0.000008   if (g:colorizer_maxlines > 0) && (g:colorizer_maxlines <= line('$'))
                                return
                              end
    1              0.000006   let w:colormatches = {}
    1              0.000011   if g:colorizer_fgcontrast != s:saved_fgcontrast || (exists("a:1") && a:1 == '!')
                                let s:force_group_update = 1
                              endif
   88              0.000224   for i in range(1, line("$"))
   87   0.050389   0.000854     call s:PreviewColorInLine(i)
   87              0.000156   endfor
    1              0.000006   let s:force_group_update = 0
    1              0.000007   let s:saved_fgcontrast = g:colorizer_fgcontrast
    1              0.000006   augroup Colorizer
    1              0.000093     au!
    1              0.000010     if exists('##TextChanged')
    1              0.000017       autocmd TextChanged * silent call s:TextChanged()
    1              0.000017       if v:version > 704 || v:version == 704 && has('patch143')
    1              0.000011         autocmd TextChangedI * silent call s:TextChanged()
    1              0.000002       else
                                    " TextChangedI does not work as expected
                                    autocmd CursorMovedI * silent call s:CursorMoved()
                                  endif
    1              0.000002     else
                                  autocmd CursorMoved,CursorMovedI * silent call s:CursorMoved()
                                endif
                                " rgba handles differently, so need updating
    1              0.000008     autocmd GUIEnter * silent call colorizer#ColorHighlight(1)
    1              0.000007     autocmd BufEnter * silent call colorizer#ColorHighlight(1)
    1              0.000008     autocmd WinEnter * silent call colorizer#ColorHighlight(1)
    1              0.000009     autocmd ColorScheme * let s:force_group_update=1 | silent call colorizer#ColorHighlight(1)
    1              0.000003   augroup END

FUNCTION  233()
Called 2 times
Total time:   0.007075
 Self time:   0.000409

count  total (s)   self (s)
    2   0.001068   0.000025     if a:path.equals(self.path)
                                    return self
                                endif
    2   0.000946   0.000035     if stridx(a:path.str(), self.path.str(), 0) ==# -1
    1              0.000003         return {}
                                endif
                            
    1              0.000004     if self.path.isDirectory
    9              0.000029         for i in self.children
    9   0.003945   0.000093             let retVal = i.findNode(a:path)
    9              0.000030             if retVal != {}
    1              0.000003                 return retVal
                                        endif
    8              0.000018         endfor
                                endif
                                return {}

FUNCTION  airline#extensions#wordcount#apply()
Called 3 times
Total time:   0.000130
 Self time:   0.000130

count  total (s)   self (s)
    3              0.000096   if &ft =~ s:filetypes
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  <SNR>118_get_array()
Called 102 times
Total time:   0.003452
 Self time:   0.003452

count  total (s)   self (s)
  102              0.000458   let fg = a:fg
  102              0.000402   let bg = a:bg
  102              0.002392   return has('gui_running') || (has("termtruecolor") && &guicolors == 1) ? [ fg, bg, '', '', join(a:opts, ',') ] : [ '', '', fg, bg, join(a:opts, ',') ]

FUNCTION  <SNR>103_InitializeVars()
Called 1 time
Total time:   0.000464
 Self time:   0.000166

count  total (s)   self (s)
                              " Description: Initialize variables
                            
    1              0.000008   if !exists('b:sig_marks')
                                " b:sig_marks = { lnum => signs_str }
    1              0.000007     let b:sig_marks = {}
    1              0.000002   else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
                                let l:line_tot = line('$')
                                call filter( b:sig_marks, 'v:key <= l:line_tot' )
                              endif
                            
    1              0.000006   if !exists('b:sig_markers')
                                " b:sig_markers = { lnum => marker }
    1              0.000005     let b:sig_markers = {}
    1              0.000002   else
                                " Lines can be removed using an external tool. Hence, we need to filter out marks placed on line numbers that are
                                " now greater than the total number of lines in the file.
                                let l:line_tot = line('$')
                                call filter( b:sig_markers, 'v:key <= l:line_tot' )
                              endif
                            
    1   0.000076   0.000028   call signature#utils#Set('b:sig_enabled'             , g:SignatureEnabledAtStartup)
    1   0.000065   0.000014   call signature#utils#Set('b:SignatureIncludeMarks'   , g:SignatureIncludeMarks    )
    1   0.000054   0.000011   call signature#utils#Set('b:SignatureIncludeMarkers' , g:SignatureIncludeMarkers  )
    1   0.000052   0.000010   call signature#utils#Set('b:SignatureMarkOrder'      , g:SignatureMarkOrder       )
    1   0.000050   0.000010   call signature#utils#Set('b:SignaturePrioritizeMarks', g:SignaturePrioritizeMarks )
    1   0.000048   0.000010   call signature#utils#Set('b:SignatureDeferPlacement' , g:SignatureDeferPlacement  )
    1   0.000047   0.000009   call signature#utils#Set('b:SignatureWrapJumps'      , g:SignatureWrapJumps       )

FUNCTION  airline#statusline()
Called 13 times
Total time:   0.000664
 Self time:   0.000664

count  total (s)   self (s)
   13              0.000297   if has_key(s:contexts, a:winnr)
   13              0.000296     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>56_CollectEnabledFileTargets()
Called 1 time
Total time:   0.000295
 Self time:   0.000119

count  total (s)   self (s)
                            
                                " Indicates which keys have already been parsed to avoid multiple entries
                                " and infinite recursion
    1              0.000025     let s:traversed = repeat([0], len(s:Dict))
                            
    1              0.000004     let lst = []
    2              0.000008     for k in a:keyList
    1   0.000222   0.000046         call extend(lst, s:DoCollectEnabledFileTargets(k))
    1              0.000005     endfor
    1              0.000009     unlet s:traversed
                            
    1              0.000003     return lst

FUNCTION  xolox#session#auto_unlock()
Called 1 time
Total time:   0.000153
 Self time:   0.000080

count  total (s)   self (s)
                              " Automatically unlock all sessions when Vim quits. Normally called by the
                              " [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1   0.000102   0.000029   if xolox#session#locking_enabled()
    1              0.000005     let i = 0
    1              0.000011     while i < len(s:lock_files)
                                  let lock_file = s:lock_files[i]
                                  if delete(lock_file) == 0
                                    call remove(s:lock_files, i)
                                  else
                                    let i += 1
                                  endif
                                endwhile
    1              0.000002   endif

FUNCTION  airline#extensions#apply()
Called 3 times
Total time:   0.000759
 Self time:   0.000382

count  total (s)   self (s)
    3              0.000021   let s:active_winnr = winnr()
                            
    3   0.000428   0.000051   if s:is_excluded_window()
                                return -1
                              endif
                            
    3              0.000013   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    3              0.000010   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    3              0.000035   if has_key(s:filetype_overrides, &ft)
                                let args = s:filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
                              endif
                            
    3              0.000026   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  <SNR>118_exec_separator()
Called 34 times
Total time:   0.026156
 Self time:   0.003191

count  total (s)   self (s)
   34   0.010439   0.000533   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   34   0.009905   0.000470   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   34              0.000333   let group = a:from.'_to_'.a:to.a:suffix
   34              0.000121   if a:inverse
   12              0.000173     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   12              0.000028   else
   22              0.000303     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   22              0.000045   endif
   34              0.000274   let a:dict[group] = colors
   34   0.004079   0.000456   call airline#highlighter#exec(group, colors)

FUNCTION  syntastic#util#unique()
Called 2 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
    2              0.000011     let seen = {}
    2              0.000009     let uniques = []
    4              0.000018     for e in a:list
    2              0.000015         if !has_key(seen, e)
    2              0.000015             let seen[e] = 1
    2              0.000028             call add(uniques, e)
    2              0.000004         endif
    2              0.000007     endfor
    2              0.000007     return uniques

FUNCTION  <SNR>122_get_seperator()
Called 17 times
Total time:   0.025222
 Self time:   0.000630

count  total (s)   self (s)
   17   0.010310   0.000286   if s:should_change_group(a:prev_group, a:group)
   17   0.014881   0.000313     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  265()
Called 1 time
Total time:   0.000106
 Self time:   0.000099

count  total (s)   self (s)
    1   0.000033   0.000026     if b:NERDTree.isWinTree()
    1              0.000005         if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
    1              0.000002     else
                                    call self._checkToCloseTree(1)
                            
                                    if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
                                        call self._previousWindow()
                                    endif
                            
                                    call self._checkToCloseTree(0)
                                endif

FUNCTION  267()
Called 1 time
Total time:   0.000150
 Self time:   0.000114

count  total (s)   self (s)
    1              0.000022     let newObj = copy(self)
                            
    1              0.000007     let newObj._path = a:path
    1   0.000022   0.000012     let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
                            
    1              0.000006     if has_key(a:opts, 'reuse')
    1              0.000008         let newObj._reuse = a:opts['reuse']
    1              0.000002     else
                                    let newObj._reuse = ''
                                endif
                            
    1   0.000020   0.000011     let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    1              0.000011     let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
    1              0.000006     let newObj._nerdtree = b:NERDTree
    1   0.000028   0.000012     call newObj._saveCursorPos()
                            
    1              0.000003     return newObj

FUNCTION  xolox#session#path_to_name()
Called 8 times
Total time:   0.000290
 Self time:   0.000164

count  total (s)   self (s)
                              " Convert the absolute pathname of a session script (the first argument,
                              " expected to be a string) to a session name. This function assumes the
                              " absolute pathname refers to the configured session directory, but it does
                              " not check for it nor does it require it (it simple takes the base name
                              " of the absolute pathname of the session script and decodes it). Returns a
                              " string.
    8   0.000239   0.000113   return xolox#misc#path#decode(fnamemodify(a:path, ':t:r'))

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 2 times
Total time:   0.000580
 Self time:   0.000079

count  total (s)   self (s)
    2   0.000540   0.000039   let errors = SyntasticStatuslineFlag()
    2              0.000015   if strlen(errors) > 0
                                return errors.(g:airline_symbols.space)
                              endif
    2              0.000005   return ''

FUNCTION  270()
Called 1 time
Total time:   0.296113
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000004     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                else
    1   0.296096   0.000011         call self._openFile()
    1              0.000002     endif

FUNCTION  271()
Called 1 time
Total time:   0.296085
 Self time:   0.000063

count  total (s)   self (s)
    1   0.001112   0.000013     if self._reuseWindow()
                                    return
                                endif
                            
    1   0.000122   0.000016     call self._gotoTargetWin()
    1   0.294830   0.000013     call self._path.edit()
    1              0.000005     if self._stay
                                    call self._restoreCursorPos()
                                endif

FUNCTION  275()
Called 1 time
Total time:   0.001099
 Self time:   0.000438

count  total (s)   self (s)
    1              0.000006     if empty(self._reuse)
                                    return 0
                                endif
                            
                                "check the current tab for the window
    1   0.000571   0.000321     let winnr = bufwinnr('^' . self._path.str() . '$')
    1              0.000008     if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                endif
                            
    1              0.000007     if self._reuse == 'currenttab'
                                    return 0
                                endif
                            
                                "check other tabs
    1   0.000438   0.000027     let tabnr = self._path.tabnr()
    1              0.000003     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec('normal! ' . tabnr . 'gt')
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . "wincmd w")
                                    return 1
                                endif
                            
    1              0.000002     return 0

FUNCTION  276()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000007     let self._bufnr = bufnr("")
    1              0.000007     let self._tabnr = tabpagenr()

FUNCTION  xolox#misc#option#get()
Called 2 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
    2              0.000030   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
    1              0.000003     return a:1
                              endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 2 times
Total time:   0.000623
 Self time:   0.000354

count  total (s)   self (s)
    2              0.000027   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
    2              0.000062     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    2              0.000004   endif
                            
    2              0.000012   if !empty(colors)
    2   0.000337   0.000068     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    2              0.000045   endif

FUNCTION  <SNR>44_detect()
Called 1 time
Total time:   0.000453
 Self time:   0.000453

count  total (s)   self (s)
    1              0.000012 	if exists("b:node_root") | return | endif
    1              0.000006 	let dir = a:dir
                            
    6              0.000013 	while 1
    6              0.000020 		let is_node = 0
    6              0.000126 		let is_node = is_node || filereadable(dir . "/package.json")
    6              0.000078 		let is_node = is_node || isdirectory(dir . "/node_modules")
    6              0.000023 		if is_node | return node#initialize(dir) | endif
                            
    6              0.000047 		let parent = fnamemodify(dir, ":h")
    7              0.000034 		if parent == dir | return | endif
    5              0.000019 		let dir = parent
    5              0.000013 	endwhile

FUNCTION  <SNR>39_QuitPreHook()
Called 1 time
Total time:   0.000713
 Self time:   0.000306

count  total (s)   self (s)
    1              0.000096     let buf = bufnr(fnameescape(a:fname))
    1   0.000160   0.000044     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
    1   0.000048   0.000014     if !syntastic#util#var('check_on_wq')
    1   0.000252   0.000048         call syntastic#util#setWids()
    1              0.000050         call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
    1              0.000003     endif
                            
    1              0.000010     if get(w:, 'syntastic_loclist_set', 0)
    1   0.000081   0.000027         call SyntasticLoclistHide()
    1              0.000002     endif

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
Called 1 time
Total time:   0.306498
 Self time:   0.000042

count  total (s)   self (s)
    1   0.306494   0.000038     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  <SNR>123_get_section()
Called 24 times
Total time:   0.001454
 Self time:   0.001309

count  total (s)   self (s)
   24              0.000181   if has_key(s:section_truncate_width, a:key)
   12              0.000107     if winwidth(a:winnr) < s:section_truncate_width[a:key]
    9              0.000024       return ''
                                endif
    3              0.000006   endif
   15              0.000079   let spc = g:airline_symbols.space
   15   0.000436   0.000291   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   15              0.000253   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   15              0.000150   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>102_SetConcealOption()
Called 1 time
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000009     if ! exists("b:indentLine_ConcealOptionSet")
    1              0.000007         let b:indentLine_ConcealOptionSet = 1
    1              0.000020         let &l:concealcursor = exists("g:indentLine_concealcursor") ? g:indentLine_concealcursor : "inc"
    1              0.000018         let &l:conceallevel = exists("g:indentLine_conceallevel") ? g:indentLine_conceallevel : "2"
    1              0.000002     endif

FUNCTION  <SNR>56_GetFileTargetList_Tracked()
Called 1 time
Total time:   0.000457
 Self time:   0.000088

count  total (s)   self (s)
    1              0.000007     let lst = [s:TrackedExt]
    1   0.000102   0.000029     let i = s:FindFileTarget(s:TrackedExt)
    1              0.000003     if i != -1
    1              0.000005         let keyList = [ i ]
    1   0.000331   0.000035         let lst = s:CollectEnabledFileTargets(keyList)
    1              0.000002     endif
    1              0.000002     return lst

FUNCTION  SyntasticStatuslineFlag()
Called 2 times
Total time:   0.000501
 Self time:   0.000050

count  total (s)   self (s)
    2   0.000498   0.000046     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  <SNR>116_get_visible_buffers()
Called 1 time
Total time:   0.002333
 Self time:   0.000449

count  total (s)   self (s)
    1   0.000701   0.000072   let buffers = airline#extensions#tabline#buflist#list()
    1              0.000012   let cur = bufnr('%')
                            
    1              0.000008   let total_width = 0
    1              0.000007   let max_width = 0
                            
    2              0.000014   for nr in buffers
    1   0.001338   0.000082     let width = len(airline#extensions#tabline#get_buffer_name(nr)) + 4
    1              0.000011     let total_width += width
    1              0.000017     let max_width = max([max_width, width])
    1              0.000009   endfor
                            
                              " only show current and surrounding buffers if there are too many buffers
    1              0.000014   let position  = index(buffers, cur)
    1              0.000006   let vimwidth = &columns
    1              0.000010   if total_width > vimwidth && position > -1
                                let buf_count = len(buffers)
                            
                                " determine how many buffers to show based on the longest buffer width,
                                " use one on the right side and put the rest on the left
                                let buf_max   = vimwidth / max_width
                                let buf_right = 1
                                let buf_left  = max([0, buf_max - buf_right])
                            
                                let start = max([0, position - buf_left])
                                let end   = min([buf_count, position + buf_right])
                            
                                " fill up available space on the right
                                if position < buf_left
                                  let end += (buf_left - position)
                                endif
                            
                                " fill up available space on the left
                                if end > buf_count - 1 - buf_right
                                  let start -= max([0, buf_right - (buf_count - 1 - position)])
                                endif
                            
                                let buffers = eval('buffers[' . start . ':' . end . ']')
                            
                                if start > 0
                                  call insert(buffers, -1, 0)
                                endif
                            
                                if end < buf_count - 1
                                  call add(buffers, -1)
                                endif
                              endif
                            
    1              0.000008   let s:current_visible_buffers = buffers
    1              0.000003   return buffers

FUNCTION  <SNR>56_SetCurrentExtension()
Called 1 time
Total time:   0.000875
 Self time:   0.000271

count  total (s)   self (s)
    1              0.000007     if !empty(&buftype)
                                    return
                                endif
    1              0.000009     let fname = bufname("%")
    1              0.000005     if empty(fname)
                                    return
                                endif
    1              0.000010     let ext = fnamemodify(fname, ":e")
    1              0.000005     if !empty(ext)
                                    let ext = "*.".ext
                                else
    1              0.000100         let ext = fnamemodify(fname, ":p:t")
    1              0.000007         if(empty(ext))
                                        return
                                    endif
    1              0.000002     endif
                            
    1   0.000182   0.000035     call s:CreateGrepDictionary()
    1   0.000491   0.000034     let tempList = s:GetFileTargetList_Tracked()
                            
                                " When in tracked mode, change the tracked extension if it isn't
                                " already in the list of files to be grepped
    1              0.000008     if index(tempList, ext) == -1
    1              0.000006         let s:TrackedExt = ext
    1              0.000011         let s:Dict[s:EasyGrepModeTracked][1] = ext
    1              0.000002     endif

FUNCTION  airline#builder#new()
Called 4 times
Total time:   0.000347
 Self time:   0.000347

count  total (s)   self (s)
    4              0.000070   let builder = copy(s:prototype)
    4              0.000034   let builder._context = a:context
    4              0.000024   let builder._sections = []
                            
    4              0.000178   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    4              0.000018   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   0.306498   0.000042  nerdtree#ui_glue#invokeKeyMap()
    1   0.306456   0.000218  171()
    1   0.296416   0.000058  170()
    1   0.296358   0.000025  <SNR>80_activateFileNode()
    1   0.296333   0.000027  199()
    1   0.296305   0.000042  216()
    1   0.296113   0.000029  270()
    1   0.296085   0.000063  271()
    1   0.294817   0.017827  111()
    1   0.178684   0.000929  signature#sign#Refresh()
    1   0.166318             signature#sign#ToggleDummy()
    1   0.051185   0.001605  colorizer#ColorHighlight()
   87   0.049535   0.009838  <SNR>55_PreviewColorInLine()
    3   0.038885   0.000128  <SNR>20_on_window_changed()
    4   0.038874   0.005185  368()
    3   0.038729   0.000782  airline#update_statusline()
    3   0.037913   0.000345  <SNR>21_invoke_funcrefs()
    5   0.033252             <SNR>87_Highlight_Matching_Pair()
   13   0.029898   0.004402  airline#check_mode()
  102   0.027096   0.007848  airline#highlighter#get_highlight()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1              0.166318  signature#sign#ToggleDummy()
    5              0.033252  <SNR>87_Highlight_Matching_Pair()
   87              0.022232  <SNR>55_RgbaColor()
    1   0.294817   0.017827  111()
  204              0.015797  <SNR>118_get_syn()
   87              0.010961  <SNR>55_RgbColor()
  102              0.010241  airline#highlighter#exec()
    2   0.010041   0.009941  ctrlp#utils#writecache()
   87   0.049535   0.009838  <SNR>55_PreviewColorInLine()
    2   0.024873   0.008270  airline#highlighter#highlight()
  102   0.027096   0.007848  airline#highlighter#get_highlight()
   87              0.006504  <SNR>55_HexCode()
    2              0.006483  signature#mark#GetList()
    4   0.038874   0.005185  368()
   52              0.004491  signature#sign#Remove()
   13   0.029898   0.004402  airline#check_mode()
    2   0.006750   0.004296  <SNR>52_mergelists()
   25              0.003772  <SNR>122_get_accented_line()
  102              0.003452  <SNR>118_get_array()
   29   0.007104   0.003224  135()

